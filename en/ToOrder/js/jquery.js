/ *! jQuery v3.3.1 | (c) Фонд JS и другие участники | jquery.org/license * /
функция (e, t) {"use strict"; "object" == typeof module && "object" == typeof module.exports? module.exports = e.document? t (e,! 0): function (e) {if (! e.document) throw new Error («jQuery требует окна с документом»); return t (e)}: t (e)} («undefined»! = typeof window? window: this, function ( e, t) {"use strict"; var n = [], r = e.document, i = Object.getPrototypeOf, o = n.slice, a = n.concat, s = n.push, u = n. indexOf, l = {}, c = l.toString, f = l.hasOwnProperty, p = f.toString, d = p.call (Object), h = {}, g = функция e (t) {return "function "== typeof t &&" number "! = typeof t.nodeType}, y = function e (t) {return null! = t && t === t.window}, v = {type:! 0, src:! 0, noModule:! 0}; функция m (e, t, n) {var i, o = (t = t || r) .createElement ("script"); if (o.text = e, n) для (i в v) n [i] && (o [i] = n [i]); t.head.appendChild (o) .parentNode.removeChild (o)} function x (e) {return null == e? e + "": "object" == typeof e || "function" == typeof e? l [c.call (e)] || " object ": typeof e} var b =" 3.3.1 ", w = function (e, t) {return new w.fn.init (e, t)}, T = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g; w.fn = w.prototype = {jquery: "3.3.1", конструктор: w, length: 0, toArray: function () {return o.call (this)}, get: function (e) {return null == e? o.call (this): e <0? this [e + this.length]: this [e]}, pushStack: function (e) {var t = w.merge (this.constructor (), e); return t.prevObject = this, t}, each: function (e) {return w.each (this, e)}, map: function (e ) {return this.pushStack (w.map (this, function (t, n) {return e.call (t, n, t)}))}, slice: function () {return this.pushStack (o.apply (this, arguments))}, first: function () {return this.eq (0)}, last: function () {return this.eq (-1)}, eq: function (e) {var t = this .length, п = е + (е <0 т: 0);return this.pushStack (n> = 0 && n <t? [this [n]]: [])}, end: function () {return this.prevObject || this.constructor ()}, push: s, sort: n .sort, splice: n.splice}, w.extend = w.fn.extend = function () {var e, t, n, r, i, o, a = arguments [0] || {}, s = 1, u = arguments.length, l =! 1; for ("boolean" == typeof a && (l = a, a = arguments [s] || {}, s ++), "object" == typeof a || г (а) || (а = {}), с === ?U && (а = это, с -); s <и; s ++), если (! = NULL (е = аргументы [s])) для ( t в e) n = a [t], a! == (r = e [t]) && (l && r && (w.isPlainObject (r) || (i = Array.isArray (r)))? (? (г = 1, а = п && Array.isArray (п) п:? []): а = п && w.isPlainObject (п) п: {}, а [т] = w.extend (л, о, г) ): void 0! == r && (a [t] = r)); return a}, w.extend ({expando: "jQuery" + ("3.3.1" + Math.random ()). replace (/ \ D / g, ""), isReady:! 0, error: function (e) {throw new Error (e)}, noop: function () {},isPlainObject: function (e) {var t, n; return! (! e || "[object Object]"! == c.call (e)) && (! (t = i (e)) || "функция "== typeof (n = f.call (t," constructor ") && t.constructor) && p.call (n) === d)}, isEmptyObject: function (e) {var t; для (t в e) return! 1; return! 0}, globalEval: function (e) {m (e)}, каждый из которых: function (e, t) {var n, r = 0, если (C (e)) {для (n = e.length; r <n; r ++), если (! 1 === t.call (e [r], r, e [r])) break} else для (r в e), если (! 1 === t.call (e [r], r, e [r])) break, return e}, trim: function (e) {return null == e? "" :( e + "") заменить (T, ")}, makeArray: function (e, t) {var n = t || []; return null! = e && (C (Object (e))? w.merge (n," string "== typeof e? [e]: e): s.call (n, e)), n}, inArray: function (e, t, n) {return null == t? -1: u.call (t, e, n) }, merge: function (e, t) {для (var n = + t.length, r = 0, i = e.length; r <n; r ++) e [i ++] = t [r]; return e. длина = я, е}, Grep:функция (e, t, n) {для (var r, i = [], o = 0, a = e.length, s =! n; o <a; o ++) (r =! t (e [o] , o))! == s && i.push (e [o]); return i}, map: function (e, t, n) {var r, i, o = 0, s = [], если (C ( e)) для (r = e.length; o <r; o ++) null! = (i = t (e [o], o, n)) && s.push (i); else для (o in e) null ! = (i = t (e [o], o, n)) && s.push (i); return a.apply ([], s)}, guid: 1, support: h}), "function" = = typeof Symbol && (w.fn [Symbol.iterator] = n [Symbol.iterator]), w.each («Логическая строка строковой функции» Дата символа RegExp «Символ ошибки» .split («»), функция (e, t) {l ["[object" + t + "]"] = t.toLowerCase ()}); функция C (e) {var t = !! e && "length" в e &&.length, n = x (e); return ! g (e) &&! y (e) && ("array" === n || 0 === t || "number" == typeof t && t> 0 && t-1 в e)} var E = function (e ) {var t, n, r, i, o, a, s, u, l, c, f, p, d, h, g, y, v,m, x, b = "sizzle" + 1 * new Date, w = e.document, T = 0, C = 0, E = ae (), k = ae (), S = ae (), D = функция (e, t) {return e === t && (f =! 0), 0}, N = {}. hasOwnProperty, A = [], j = A.pop, q = A.push, L = A. push, H = A.slice, O = function (e, t) {для (var n = 0, r = e.length; n <r; n ++) if (e [n] === t) return n; вернуться-1}, P = "проверен | выбрана | асинхронный | автофокусировка | автовоспроизведение | управления | отложить | инвалиды | скрытый | ISMAP | цикл | кратно | открыты | только для чтения | требуется | область действия", М = "[\\ x20 \\ т \\ г \\ п \\ е] "R = "(?:. \\\\ | [\\ w-] | [^ \ 0 - \\ xa0]) +" I =" \\ [ "+ M +" * ( "+ R +") (?: "+ M +" * ([* ^ $ | ~] =) "+ M +" * (!? ((: \\\\?. | [^ \\\\ ']) *)' | \ "((?:. \\\\ | [^ \\\\\"]) *) \ "| (" + R + ")) |) "+ M +" * \\] "W = ":(" + R +") (: \\ (((? ((?:. \\\\ | [^ \\\\ ']) *) «| \ "((?:. \\\\ | [^ \\\\\"]) *) \") | ((?:. \\\\ | [^ \\\\ () [\ \]] | "+ I +") *) |.*) \\) |) ", $ = новый RegExp (M +" + "," g "), B = новый RegExp (" ^ "+ M +" + | ((?: ^ | [^ \\\\] ) (?: \\\\.) *) "+ M +" + $ "," g "), F = новый RegExp (" ^ "+ M +" *, "+ M +" * "), _ = новый RegExp ("^" + M + "* ([> + ~] |" + M + ")" + M + "*"), z = новый RegExp ("=" + M + "* ([^ \\] '\"] *?) "+ M +" * \\] "," g "), X = новый RegExp (W), U = новый RegExp (" ^ "+ R +" $ "), V = {ID: новый RegExp (" ^ # ("+ R +") "), CLASS: новый RegExp (" ^ \\. ("+ R +") "), TAG: новый RegExp (" ^ ("+ R +" | [*]) ") ATTR: новый RegExp («^» + I), PSEUDO: новый RegExp («^» + W), CHILD: новый RegExp («^ :( только | первый | последний | nth | nth-last) - (child | of -типа) (: \\ ( "+ M +" * (четные | нечетные | (([+ -] |) (\\ д *) п |) "+ M +" * (?:? ([+ -] | ) "+ M +"* (\\ d +) |)) "+ M +" * \\) |) "," i "), bool: новый RegExp (" ^ (?: "+ P +") $ "," i "), needsContext : новый RegExp ("^" + M + "* [> + ~] |: (четный | нечетный | eq | gt | lt | nth | first | last) (?: \\ (" + M + "* ((?: ? - \\ г) \\ д *) "+ M +" * \\) |) (= [^ -] |? $)», "я")}, С = / ^ (?: вход | выбрать | textarea | button) $ / i, Y = / ^ h \ d $ / i, Q = / ^ [^ {] + \ {\ s * \ [native \ w /, J = / ^ (?: # ([ \ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, K = / [+ ~] /, Z = новый RegExp ("\\\\ ([\\ da -f] {1,6} "+ M +"? ("+ M +") |.) "," ig "), ee = function (e, t, n) {var r =" 0x "+ t- 65536; return r! == r || n? T: r <0? String.fromCharCode (r + 65536): String.fromCharCode (r >> 10 | 55296,1023 & r | 56320)}, te = / ([\ 0 - \ x1f \ x7f] | ^ -? \ D) | ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w -] / g, ne = функция (e, t) {return t? "\ 0" === е "\ ufffd": e.slice (0, -1) + "\\" + e.charCodeAt (e.length-1).toString (16) + "": "\\" + e}, re = function () {p ()}, т.е. = me (function (e) {return! 0 === e.disabled && ("form" in e || "label" в e)}, {dir: "parentNode", next: "legend"}); try {L.apply (A = H.call (w.childNodes), w.childNodes), A [ w.childNodes.length] .nodeType} поймать (е) {L = {применяется: a.length функции (е, т) {q.apply (е, H.call (т))}: функция (е, т ) {var n = e.length, r = 0, тогда как (e [n ++] = t [r ++]); e.length = n-1}}} function oe (e, t, r, i) {var o , s, l, c, f, h, v, m = t && t.ownerDocument, T = t? t.nodeType: 9; if (r = r || [], "string"! = typeof e ||! e || 1! == T && 9! == T && 11! == T) return r; if (! I && ((t? T.ownerDocument || t: w)! == d && p (t), t = t || d , г)) {если (11! == Т && (е = J.exec (е))), если (о = F [1]) {если (9 === Т) {если (! (L ??= т. getElementById (o))) return r; if (l.id === o) return r.push (l), r} else if (m && (l = m.getElementById (o)) && x (t, l) && l.id === o) return r.push (l), r} else {if (f [2]) return L.apply (r, t.getElementsByTagName (e)), r; if ((o = f [3]) && n.getElementsByClassName && t.getElementsByClassName) return L.apply (r, t.getElementsByClassName (o)), r} if (n.qsa &&! S [e + ""] && (! Y ||! Y.test ( e))) {if (1! == T) m = t, v = e, else if ("object"! == t.nodeName.toLowerCase ()) {(c = t.getAttribute ("id") ) с = c.replace (т, п): t.setAttribute ( "идентификатор", с = б), с = (Н = а (е)?.) длина, в то время (ы -) ч [с] = "#" + c + "" + ve (h [s]); v = h.join (","), m = K.test (e) && ge (t.parentNode) || t}, если (v) попробуйте {return L.apply (r, m.querySelectorAll (v)), r} catch (e) {} наконец {c === b && t.removeAttribute ("id")}}} return u (e.replace (B, "$ 1"), t, r, i)} функция ae () {var e = []; функция t (n, i) {return e.push (n + "")> r.cacheLength && delete t [e.shift ()], t [n + ""] = i} return t} function se (e) {return e [b] =! 0, e} функция uue (e) {var t = d.createElement ("fieldset" ), try {return !! e (t)} catch (e) {return! 1} finally {t.parentNode && t.parentNode.removeChild (t), t = null}} function le (e, t) {var n = e.split ("|"), i = n.length, тогда как (i -) r.attrHandle [n [i]] = t} функция ce (e, t) {var n = t && e, r = n && 1 = == e.nodeType && 1 === t.nodeType && e.sourceIndex-t.sourceIndex; if (r) return r; if (n) while (n = n.nextSibling) if (n === t) return-1; return e? 1: -1} функция fe (e) {return function (t) {return "input" === t.nodeName.toLowerCase () && t.type === e}} function pe (e) {return function (t) {var n = t.nodeName.toLowerCase (); return ("input" === n || "button" === n) && t.type === e}} function de (e) {return function (t) {return "form" в t? t.parentNode &&! 1 === t.disabled? "label" в t? "label" в t.parentNode? t.parentNode.disabled === e: t.disabled === e: t.isDisabled === e || t.isDisabled! ==! e && ie (t) === e: t.disabled === e: "label" в t && t.disabled === e}} функция he (e) {return se (function (t) {return t = + t, se (функция (n, r) {var i, o = e ([], n.length, t), a = o.length, тогда как (a -) n [i = o [a]] && (n [i] =! (r [i] = n [i]))})})} function ge (e) {return e && "undefined"! = typeof e.getElementsByTagName && e} n = oe.support = {}, o = oe.isXML = function (e) {var t = e && (e.ownerDocument || e) .documentElement; return !! t && "HTML"! == t.nodeName}, p = oe.setDocument = function (e) {var t, i, a = e? e.ownerDocument || e: w; return a! == d && 9 === a.nodeType && a.documentElement? (d = a, h = d.documentElement, g =! o ( г), ш! == д && (я = d.defaultView) && i.top! == я && (i.addEventListener? я.addEventListener ("unload", re,! 1): i.attachEvent && i.attachEvent ("onunload", re)), n.attributes = ue (function (e) {return e.className = "i",! e.getAttribute ("className")}), n.getElementsByTagName = ue (функция (e) {return e.appendChild (d.createComment ("")) ,! e.getElementsByTagName ("*"). length}), n.getElementsByClassName = Q.test (d.getElementsByClassName), n.getById = ue (функция (e) {return h.appendChild (e) .id = b,! D.getElementsByName ||! D.getElementsByName (b) .length}) , n.getById? (r.filter.ID = function (e) {var t = e.replace (Z, ee); return function (e) {return e.getAttribute ("id") === t}} , r.find.ID = function (e, t) {if ("undefined"! = typeof t.getElementById && g) {var n = t.getElementById (e); return n? [n]: []}}): (r.filter.ID = function (e) {var t = e.replace (Z, ee); return function (e) {var n = "undefined"!= typeof e.getAttributeNode && e.getAttributeNode ("id"); return n && n.value === t}}, r.find.ID = function (e, t) {if ("undefined"! = typeof t.getElementById && g) { var n, r, i, o = t.getElementById (e), if (o) {if ((n = o.getAttributeNode ("id")) && n.value === e) return [o]; i = t.getElementsByName (е), г = 0, в то время (о = я [г ++]), если ((п = o.getAttributeNode ( "ID")) && n.value === е) возвращение [о]} возвращение [] }}), r.find.TAG = n.getElementsByTagName? function (e, t) {return "undefined"! = typeof t.getElementsByTagName? t.getElementsByTagName (e): n.qsa? t.querySelectorAll (e): void 0}: function (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {while (n = o [i ++ ]) 1 === n.nodeType && r.push (n); return r} return o}, r.find.CLASS = n.getElementsByClassName && function (e, t) {if ("undefined"! = Typeof t.getElementsByClassName && g) return t.getElementsByClassName (e)}, v = [], y = [], (n.qsa = Q.test (d.querySelectorAll)) && (ue (function (e) {h.appendChild (e) .innerHTML = "<a id='"+b+"'> </a> <select id = '" + b + "- \ r \\' msallowcapture = ''> <option selected = ''> </ option> </ выберите>», e.querySelectorAll ( "[msallowcapture ^ = '']") длина && y.push. ( "[* ^ $] =" + M + "* (?: '' | \" \ ")") , e.querySelectorAll ( "[выбран]") длина || y.push ( "\\ [" + M + "* (?: значение |" + P + ")")., e.querySelectorAll ( "[ID = ~ "+ B +" -] ") длина || y.push (" ~ = "), e.querySelectorAll (": проверено ") длина || y.push (.": проверено "), e.querySelectorAll (" A # "+ б +" + * "). длина || у.push (". #. + [+ ~]")}), ue (функция (e) {e.innerHTML = "<a href='' disabled='disabled'> </a> <select disabled = 'disabled '> <option /> </ select> "; var t = d.createElement (" input "); t.setAttribute (" type "," hidden "), e.appendChild (t) .setAttribute (" name "," "D"), e.querySelectorAll ( "[имя = d]") длина && y.push ( "имя" + M +. "*? [* ^ $ |! ~] ="), 2 == e.querySelectorAll (! ": включено") длина && y.push (. ": включено", ": отключено"), h.appendChild (е) .disabled = 0,2 == e.querySelectorAll (! ": отключено".) длина && y.push ( ": включено", ": отключено"), e.querySelectorAll ( "* ,: х"), ( "y.push, *:.")})), (n.matchesSelector = Q.test (м = h.matches || h.webkitMatchesSelector || ч.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && ие (функция (е) {n.disconnectedMatch = m.call (е, "*"), m.call (е, "[s = '']: x "), v.push ("! = ", W)}), y = y.length && new RegExp (y.join (" | ")), v = v.length && new RegExp (v.join (" | ") ), t = Q.test (h.compareDocumentPosition), x = t || Q.test (h.contains)? function (e, t) {var n = 9 === e.nodeType? e.documentElement: e , r = t && t.parentNode; return e === r ||! (! r || 1! == r.nodeType ||! (n.contains? n.contains (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition (r )))}:!? функция (е, т) {если (т), а (т = t.parentNode), если (т === е) возвращают 0; 1} вернуться, D = т функция (е, т ) {if (e === t) return f =! 0,0; var r =! e.compareDocumentPosition-! t.compareDocumentPosition; return r || (1 & (r = (e.ownerDocument || e) == = (t.ownerDocument || т) e.compareDocumentPosition (т): 1) || п!.sortDetached && t.compareDocumentPosition (е) === г е === д || e.ownerDocument === ш && х (ш, е) - 1:? т === д || t.ownerDocument === ш && х (ш , t)? 1: c? O (c, e) -O (c, t): 0: 4 & r? -1: 1)}: функция (e, t) {if (e === t) возвращает f =! 0,0; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; if (! I ||! O) return e == ? = d-1: т === д 1: я -1: о 1: C O (с, е) -O (C, T):?? 0; если (я === о) возвращение се (е, т); п = е; при этом (п = n.parentNode) a.unshift (п); п = т, в то время как (п = n.parentNode) s.unshift (п), в то время (в [г ] === s [r]) r ++; return r? ce (a [r], s [r]): a [r] === w? -1: s [r] === w? 1: 0}, d): d}, oe.matches = function (e, t) {return oe (e, null, null, t)}, oe.matchesSelector = function (e, t) {if ((e.ownerDocument || e)! == d && p (e), t = t.replace (z, "= '$ 1']"), n.matchesSelector && g &&! S [t + ""] && (! v ||! v.test ( t)) && (! y ||! y.test (t))) try {var r = m.call (e, t); if (r || n.disconnectedMatch || e.document && 11! == e.document.nodeType) return r} catch (e) {} return oe (t, d, null, [e]). length> 0}, oe.contains = function (e, t) {return (e.ownerDocument || e)! == d && p (e), x (e, t)}, oe.attr = function (e, t) {(e.ownerDocument || e)! == d && p (e); var i = r. attrHandle [t.toLowerCase ()], o = i && N.call (r.attrHandle, t.toLowerCase ())? i (e, t,! g): void 0; return void 0! == o? o: n .attributes || г e.getAttribute (т) :( а = e.getAttributeNode (т)) && o.specified o.value:? нуль}, oe.escape = функция (е) {возвращение (е + "") .replace (te, ne)}, oe.error = function (e) {throw new Error ("Синтаксическая ошибка, нераспознанное выражение:" + e)}, oe.uniqueSort = function (e) {var t, r = [ ], г = 0, а = 0; если (! F = n.detectDuplicates, с = n.sortStable && e.slice (0), e.sort (D), е) {в то время (т = е [о ++]) t === e [o] && (i = r.push (o)); while (i -) e.splice (r [i], 1)} return c = null, e}, i = oe. getText = function (e) {var t, n = "", r = 0, o = e.nodeType;if (o) {if (1 === o || 9 === o || 11 === o) {if ("string" == typeof e.textContent) return e.textContent; для (e = e .firstChild; e; e = e.nextSibling) n + = i (e)} else if (3 === o || 4 === o) возвращает e.nodeValue} else while (t = e [r ++]) n + = i (t); return n}, (r = oe.selectors = {cacheLength: 50, createPseudo: se, match: V, attrHandle: {}, find: {}, relative: {">": {dir: "parentNode", сначала:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", first:! 0}, "~": {dir: "previousSibling"}} , preFilter: {ATTR: function (e) {return e [1] = e [1]. Replace (Z, ee), e [3] = (e [3] || e [4] || e [5 ] || ""), заменим (Z, ee), "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice (0, 4)}, CHILD: function (e) {return e [1] = e [1] .toLowerCase (), "nth" === e [1] .slice (0,3)? (E [3] | ? | oe.error (е [0]), е [4] = + (е [4] е [5] + (е [6] || 1): 2 * ( "даже"=== е [3] || "нечетным" === е [3])), е [5] = + (е [7] + е [8] || "нечетным" === е [3] )): e [3] && oe.error (e [0]), e}, PSEUDO: function (e) {var t, n =! e [6] && e [2]; return V.CHILD.test (e [0]) нуль: (? е [3] е [2] = е [4] || е [5] || "": п && X.test (п)! && (т = а (п, 0) ) && (т = n.indexOf ( ")", n.length-т) -n.length) && (е [0] = е [0] .slice (0, т), е [2] = п. slice (0, t)), e.slice (0,3))}}, filter: {TAG: function (e) {var t = e.replace (Z, ee) .toLowerCase (); return "*" === e? function () {return! 0}: function (e) {return e.nodeName && e.nodeName.toLowerCase () === t}}, CLASS: function (e) {var t = E [e + " "]; return t || (t = new RegExp (" (^ | "+ M +") "+ e +" ("+ M +" | $) ")) && E (e, function (e) {return t.test ("string" == typeof e.className && e.className || "undefined"! = typeof e.getAttribute && e.getAttribute ("class") || "")})}, ATTR: function (e, t, n) {return function (r) {var i = oe.attr (r, e); return null == i? === т "=!": т || (я + = "", "=" === т я === п? "! =" === т я == п:?! "^ = "=== Тп && 0 === i.indexOf (п):" * = "=== Тп && i.indexOf (п)> - 1:"? $ = "=== Тп && i.slice ( -n.length) === n: "~ =" === t? ("" + i.replace ($, "") + "") .indexOf (n)> - 1: "| =" = == т && (я === п || i.slice (0, n.length + 1) === п + "-"))}}, РЕБЕНОК: функция (е, т, п, г, я) { var o = "nth"! == e.slice (0,3), a = "last"! == e.slice (-4), s = "of-type" === t; return 1 == = r && 0 === i? function (e) {return !! e.parentNode}: function (t, n, u) {var l, c, f, p, d, h, g = o! == a? "NextSibling": "PreviousSibling", у = t.parentNode, V = S && t.nodeName.!! ToLowerCase (), м = и && с, х = 1;!, Если (у) {если (о) {в то время как (г) {р = т, в то время как (р = р [г]), если (ы р?. nodeName.toLowerCase () === V: 1 === p.nodeType) возвращает 1; ч = г = "только" === е && && ч "NextSibling"} возвращают 0}, если (А = [а!!!? y.firstChild: y.lastChild], его && м) {х = (г = (л = (с = (е = (р = у) [Ь] || (р [Ь] = {})) [p.uniqueID ] || (е [p.uniqueID] = {})) [е] || []) [0] === Т && л [1]) && л [2], р = д && y.childNodes [d]; в то время ( р = ++ d && && р р [г] || (х = д = 0) || h.pop ()), если (1 === p.nodeType && ++ х && р === т) {с [е] = [Т , d, x]; break}} else if (m && (x = d = (l = (c = (f = (p = t) [b] || (p [b] = {})) [p. UniqueID] || (е [p.uniqueID] = {})) [е] || []) [0] === Т && л [1]) ,! 1 === х), а (р = ++ d && && р р [г] || (х = д = 0) || h.pop ()), если ((с p.nodeName.toLowerCase () === v: 1 === p.nodeType) && ++ х && ( м && ((с = (F = P [Ь] || (р [Ь] = {})) [p.uniqueID] || (е [p.uniqueID] = {})) [е] = [Т, Икс]),p === t)) break; return (x- = i) === r || x% r == 0 && x / r> = 0}}}, PSEUDO: function (e, t) {var n, i = r.pseudos [e] || r.setFilters [e.toLowerCase ()] || oe.error ("unsupported pseudo:" + e); return i [b]? i (t): i.length> 1 (n = [e, e, "", t], r.setFilters.hasOwnProperty (e.toLowerCase ())? se (функция (e, n) {var r, o = i (e, t), a = o.length, тогда как (a -) e [r = O (e, o [a])] =! (n [r] = o [a])}): function (e) {return i (e , 0, n)}): i}}, pseudos: {not: se (function (e) {var t = [], n = [], r = s (e.replace (B, "$ 1")) , return r [b]? se (function (e, t, n, i) {var o, a = r (e, null, i, []), s = e.length, тогда как (s -) ( o = a [s]) && (e [s] =! (t [s] = o))}): функция (e, i, o) {return t [0] = e, r (t, null, o, n), t [0] = null,! n.pop ()}}) имеет: se (function (e) {return function (t) {return oe (e, t) .length> 0}} ), содержит: se (function (e) {return e = e.replace (Z, ee), function (t) {return (t.textContent || t.innerText || i (t)). indexOf (e) > -1}}), языки:se (function (e) {return U.test (e || "") || oe.error ("unsupported lang:" + e), e = e.replace (Z, ee) .toLowerCase (), function ( t) {var n; do {if (n = g? t.lang: t.getAttribute ("xml: lang") || t.getAttribute ("lang")) return (n = n.toLowerCase ()) = == 0 || е === n.indexOf (е + "-")} в то время как ((т = t.parentNode) && 1 === t.nodeType); возвращать 1}}), цель: функция (т)! {var n = e.location && e.location.hash; return n && n.slice (1) === t.id}, root: function (e) {return e === h}, focus: function (e) {return (! d.hasFocus || d.hasFocus ()) е === d.activeElement && && !! (e.type || e.href || ~ e.tabIndex)}, включен: (! 1) де, инвалидов : de (! 0), checked: function (e) {var t = e.nodeName.toLowerCase (); return "input" === t && !! e.checked || "option" === t && !! e .selected}, selected: function (e) {return e.parentNode && e.parentNode.selectedIndex ,!0 === e.selected}, пусто: функция (е) {для (е = e.firstChild, е, е = e.nextSibling), если (e.nodeType <6) возвращает 1, возвращение 0}, родители! : function (e) {return! r.pseudos.empty (e)}, header: function (e) {return Y.test (e.nodeName)}, input: function (e) {return G.test (e. nodeName)}, button: function (e) {var t = e.nodeName.toLowerCase (); return "input" === t && "button" === e.type || "button" === t}, text: function (e) {var t; return "input" === e.nodeName.toLowerCase () && "text" === e.type && (null == (t = e.getAttribute ("type")) || "текст" === t.toLowerCase ())}, первый: он (функция () {вернуться [0]}), последнее: он (функция (е, т) {вернуться [т-1]}) , eq: he (функция (e, t, n) {return [n <0? n + t: n]}), even: he (функция (e, t) {для (var n = 0; n <t ; n + = 2) e.push (n); return e}), нечетный: he (функция (e, t) {для (var n = 1; n <t; n + = 2) e.push (n); return e}), lt: he (функция (e, t,n) {для (var r = n <0? n + t: n; - r> = 0;) e.push (r); return e}), gt: he (function (e, t, n) {for (var r = n <0? n + t: n; ++ r <t;) e.push (r); return e})}}). pseudos.nth = r.pseudos.eq; для ( t в {radio:! 0, checkbox:! 0, file:! 0, password:! 0, image:! 0}) r.pseudos [t] = fe (t); for (t in {submit:! 0 , reset:! 0}) r.pseudos [t] = pe (t); function ye () {} ye.prototype = r.filters = r.pseudos, r.setFilters = new ye, a = oe.tokenize = функция (e, t) {var n, i, o, a, s, u, l, c = k [e + ""], если (c) возвращает t? 0: c.slice (0); s = e , и = [], л = r.preFilter;! в то время (ы) {п && (я = F.exec (ы)) || (я && (с = s.slice (я [0] .length) || ы !.), u.push (о = [])), п = 1, (я = _ Exec (ы)) && (п = i.shift (), o.push ({значение: п, тип: я [0] .replace (B, "")}), s = s.slice (n.length)), для (a в r.filter)! (I = V [a] .exec (s)) || ! л [а] && (г = л [а] (я)) || (п = i.shift (), o.push ({значение: п, тип: а, соответствует: I}), s = s .slice (n.length)); if (! n) break} return t? s.length: s? oe.error (e):k (e, u) .slice (0)}, функция ve (e) {для (var t = 0, n = e.length, r = ""; t <n; t ++) r + = e [t]. значение; return r} function me (e, t, n) {var r = t.dir, i = t.next, o = i || r, a = n && "parentNode" === o, s = C ++; return t.first? function (t, n, i) {while (t = t [r]) if (1 === t.nodeType || a) return e (t, n, i); return! 1} : function (t, n, u) {var l, c, f, p = [T, s]; if (u) {while (t = t [r]) if ((1 === t.nodeType | | a) && e (t, n, u)) return! 0} else while (t = t [r]), если (1 === t.nodeType || a), если (f = t [b] || ( т [Ь] = {}), с = F [t.uniqueID] || (е [t.uniqueID] = {}), я && я === t.nodeName.toLowerCase ()) Т = Т [г] | | t; else {if ((l = c [o]) && l [0] === T && l [1] === s) return p [2] = l [2], если (c [o] = p , p [2] = e (t, n, u)) return! 0} return! 1}} function xe (e) {return e.length> 1? function (t, n, r) {var i = e .length, while (i -), если (! e [i] (t, n, r)) return! 1; return! 0}: e [0]} функция be (e, t, n) {для ( var r = 0, i = t.length, r <i; r ++) oe (e, t [r], n); return n} function we (e, t, n,r, i) {для (var o, a = [], s = 0, u = e.length, l = null! = t; s <u; s ++) (o = e [s]) && (n &&! n (o, r, i) || (a.push (o), l && t.push (s))), вернуть a} функцию Te (e, t, n, r, i, o) {return r &&! r [b] && (r = Te (r)), i &&! i [b] && (i = Te (i, o)), se (функция (o, a, s, u) {var l, c, f !, р = [], d = [], ч = a.length, г = о || быть (? Т || "*", s.nodeType [с]: с, []), у = е | !??? | о && т г: мы (г, р, е, з, и), V = п я || (МР E: H || г) []: A: Y; если (п && п (у, V, s, и), г) {л = мы (V, г), г (л, [], s, U), с = l.length, в то время (с -) (е = L [с] ) && (v [d [с]]! = (у [д [с]] = е))}, если (о) {если (я || е) {если (я) {л = [], с = v.length, в то время (с -) (е = v [с]) && l.push (у [с] = е); я (нуль, v = [], л, и)} с = v.length; в то время как (с -) (е = v [с]) && (л = I O (O, F):? р [с])> - 1 && (о [л] = (а [л] = е)! )}} else v = we (v === a? v.splice (h, v.length): v), i? i (null, a, v, u): L.apply (a, v)} )} функция Ce (e) {для (var t, n, i, o = e.length, a = r.relative [e [0] .type], s = a || r.относительный [""], u = a? 1: 0, c = me (function (e) {return e === t}, s,! 0), f = me (function (e) {return O (t , e)> - 1}, s,! 0), p = [function (e, n, r) {var i =! a && (r || n! == l) || ((t = n). nodeType? c (e, n, r): f (e, n, r)); return t = null, i}]; u <o; u ++), если (n = r.relative [e [u] .type ]) р = [я (х (р), п)], иначе {если ((п = r.filter [е [и] .type] .Нанесите (нуль, е [и] .matches)) [Ь] ) {для (i = ++ u; i <o; i ++), если (r.relative [e [i] .type]) break, верните Te (u> 1 && xe (p), u> 1 && ve (e.slice ( 0, u-1) .concat ({значение: "" === e [u-2] .type? "*": ""})) Заменить (B, "$ 1"), n, u <i && Ce (e.slice (u, i)), i <o && Ce (e = e.slice (i)), i <o && ve (e))} p.push (n)} return xe (p)} функция Ee (e , t) {var n = t.length> 0, i = e.length> 0, o = function (o, a, s, u, c) {var f, h, y, v = 0, m = " 0" , х = о && [], Ь = [], W = L, C = O || я && r.find.TAG ( "*", с), Е = Т + = NULL == ш 1: Math.случайное () || 0,1, к = C.length, ибо (с && (л = а === д || а || с);! м == && к нулю = (F = C [м]);! M ++ ) {если (я && е) {Н = 0, а || f.ownerDocument === д || (р (е), с = г);!, а (у = е [ч ++]), если (у (F, а || д, з)) {u.push (е); перерыв}! с && (Т = Е)} п && ((е = у && е) && v -, о && x.push (е))}, если (V + = т , п && м == v) {ч = 0; у, а (у = т [ч ++]) (х, Ь, а, с);!, если (о) {если (v> 0), а (м -) х [м] || Ь [м] || (б [м] = j.call (и));! = Ь мы (б)} L.apply (и, б), в && && о b.length> 0 && у + т .length> 1 && oe.uniqueSort (u)} return c && (T = E, l = w), x}; return n? se (o): o} return s = oe.compile = function (e, t) {var n, r = [], i = [], o = S [e + ""], если (! o) {t || (t = a (e)), n = t.length, тогда как (n-- ) (о = С (т [п])) [б] r.push?. (о): i.push (о); (O = S (E, Ee (I, R))) селектор = е} return o}, u = oe.select = function (e, t, n, i) {var o, u, l, c, f, p = "function" == typeof e && e, d =! i && a (e = p .Селекторный || е);если (п = п || [], 1 === D.Length) {если ((U = D [0] = D [0] .slice (0)). длина> 2 && "ИД" === ( л = и [0]). тип && 9 === t.nodeType && г && r.relative [U [1] .Type]) {если (! (т = (r.find.ID (l.matches [0] .Надеть (Z , ee), t) || []) [0])) return n; p && (t = t.parentNode), e = e.slice (u.shift (). value.length)} o = V.needsContext .test (е) 0: u.length; в то время как (о -) {если (л = и [о], r.relative [с = l.type]) перерыва, если ((е = r.find [ с]) && (я = F (l.matches [0] .Надеть (Z, й), K.test (и [0] .type) && GE (t.parentNode) || т))) {если (U .splice (o, 1),! (e = i.length && ve (u))) return L.apply (n, i), n; break}}} return (p || s (e, d)) (i , т,! г, п,! т || K.test (е) && GE (t.parentNode) || т), п}, n.sortStable = b.split ( ""). рода (D), .join ("") === b, n.detectDuplicates = !! f, p (), n.sortDetached = ue (функция (e) {return 1 & e.compareDocumentPosition (d.createElement ("fieldset"))}),ue (функция (e) {return e.innerHTML = "<a href='#'> </a>", "#" === e.firstChild.getAttribute ("href")}) || le (" type | href | height | width, function (e, t, n) {if (! n) return e.getAttribute (t, "type" === t.toLowerCase ()? 1: 2)}), n .attributes && ue (function (e) {return e.innerHTML = "<input />", e.firstChild.setAttribute ("value", ""), "" === e.firstChild.getAttribute ("value")} ) || le («значение», функция (e, t, n) {if (! n && "input" === e.nodeName.toLowerCase ()) return e.defaultValue}), ue (function (e) { return null == e.getAttribute ("disabled")}) || le (P, function (e, t, n) {var r; if (! n) return! 0 === e [t]? t. toLowerCase () :( г = e.getAttributeNode (т)) && r.specified r.value: NULL}), ае} (е); w.find = е, w.expr = E.selectors, w.expr [ ":"] = w.expr.pseudos, w.uniqueSort = w.unique = E.uniqueSort, w.text = E.getText, w.isXMLDoc = E.isXML, w.contains = E.contains, w.escapeSelector = E.escape; var k = function (e, t, n) {var r = [], i = void 0! == n; while ((e = e [t]) && 9! == e.nodeType) if (1 === e.nodeType ) {if (i && w (e) .is (n)) break; r.push (e)} return r}, S = function (e, t) {для (var n = []; e; e = e. nextSibling) 1 === e.nodeType && e! == t && n.push (e); return n}, D = w.expr.match.needsContext; function N (e, t) {return e.nodeName && e.nodeName.toLowerCase ( ) === t.toLowerCase ()} var A = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> |) $ / i; функция j (e, t, n) {return g (t)? w.grep (e, function (e, r ) {return !! t.call (e, r, e)! == n}): t.nodeType? w.grep (e, function (e) {return e === t! == n}): "string"! = typeof t? w.grep (e, function (e) {return u.call (t, e)> - 1! == n}): w.filter (t, e, n)} w .filter = function (e, t, n) {var r = t [0];return n && (e = ": not (" + e + ")"), 1 === t.length && 1 === r.nodeType? w.find.matchesSelector (r, e)? [r]: []: w .find.matches (e, w.grep (t, function (e) {return 1 === e.nodeType}))}, w.fn.extend ({find: function (e) {var t, n, r = this.length, i = this, if ("string"! = typeof e) возвращает this.pushStack (w (e) .filter (function () {for (t = 0; t <r; t ++), если ( w.contains (я [т], это)) возвращают 0}));! для (п = this.pushStack ([]), т = 0; т <R, T ++) w.find (E, I [т ], n); return r> 1? w.uniqueSort (n): n}, filter: function (e) {return this.pushStack (j (это, e || [] ,! 1))}, а не: function (e) {return this.pushStack (j (this, e || [] ,! 0))}, является: function (e) {return !! j (this, "string" == typeof e && D.test ( e)? w (e): e || [], 1) .length}}), var q, L = / ^ (?: \ s * (<[\ w \ W] +>) [^> ] * | # ([\ w -] +)) $ /; (w.fn.init = function (e, t, n) {var i, o; if (! e) возвращает это, если (n = n || q, "string" == typeof e) {if (! (i = "<"=== е [0] &&"> "=== е [e.length-1] && e.length> = 3 [нуль, е, нуль]:! L.exec (е)) || я [ 1] && т) возвращают т || t.jquery (т || п) .find (е):!? this.constructor (т) .find (е), если (я [1]) {если (т = т instanceof w? t [0]: t, w.merge (это, w.parseHTML (i [1], t && t.nodeType? t.ownerDocument || t: r,! 0)), A.test (i [1 ]) && w.isPlainObject (t)) для (i в t) g (это [i])? это [i] (t [i]): this.attr (i, t [i]); верните это} return (o = r.getElementById (i [2])) && (this [0] = o, this.length = 1), this} return e.nodeType? (это [0] = e, this.length = 1, это): g (e)? void 0! == n.ready? n.ready (e): e (w): w.makeArray (e, this)}). prototype = w.fn, q = w ( r), var H = / ^ (?: parent | prev (?: Until | All)) /, O = {children:! 0, contents:! 0, next:! 0, prev:! 0}; w. fn.extend ({has: function (e) {var t = w (e, this), n = t.length; return this.filter (function () {for (var e = 0; e <n; e ++) если (w.contains (это, т [е])) возвращает 0})}, ближайшая: функция (е,t) {var n, r = 0, i = this.length, o = [], a = "string"! = typeof e && w (e), если (! D.test (e)) для (; r <i ; г ++), для (п = это [г]; п && п == т; п = n.parentNode), если (n.nodeType <11 && (а a.index (п)?> - 1: 1 === п!. nodeType && w.find.matchesSelector (n, e))) {o.push (n); break} return this.pushStack (o.length> 1? w.uniqueSort (o): o)}, index: function (e) {return e? "string" == typeof e? u.call (w (e), это [0]): u.call (это, e.jquery? e [0]: e): this [0] && this [0] .parentNode? This.first (). PrevAll (). Length: -1}, add: function (e, t) {return this.pushStack (w.uniqueSort (w.merge (this.get (), w (e, t))))}, addBack: function (e) {return this.add (null == e? this.prevObject: this.prevObject.filter (e))}}), функция P (e, t) {while ((e = e [t]) && 1! == e.nodeType); return e} w.each ({parent: function (e) {var t = e.parentNode; return t && 11! == t .nodeType т: нулевой}, родители:function (e) {return k (e, "parentNode")}, parentsUntil: function (e, t, n) {return k (e, "parentNode", n)}, next: function (e) {return P ( e, "nextSibling")}, prev: function (e) {return P (e, "previousSibling")}, nextAll: function (e) {return k (e, "nextSibling")}, prevAll: function (e) {return k (e, "previousSibling")}, nextUntil: function (e, t, n) {return k (e, "nextSibling", n)}, prevUntil: function (e, t, n) {return k ( e, "previousSibling", n)}, siblings: function (e) {return S ((e.parentNode || {}). firstChild, e)}, children: function (e) {return S (e.firstChild) }, content: function (e) {return N (e, "iframe")? e.contentDocument: (N (e, "template") && (e = e.content || e), w.merge ([] , e.childNodes))}}, функция (e, t) {w.fn [e] = function (n, r) {var i = w.map (это, t, n); return "Until"! = = e.slice (-5) && (г = п), г && "string" == typeof r && (i = w.filter (r, i)), this.length> 1 && (O [e] || w.uniqueSort (i), H.test (e) && i.reverse ( )), this.pushStack (i)}}); var M = / [^ \ x20 \ t \ r \ n \ f] + / g; функция R (e) {var t = {}; return w.each (e.match (M) || [], функция (e, n) {t [n] =! 0}), t} w.Callbacks = function (e) {e = "string" == typeof e? R (e): w.extend ({}, e); var t, n, r, i, o = [], a = [], s = -1, u = function () {для (i = i || e.once, г = т = 0;! a.length; s = -1) {п = a.shift (!), в то время как (++ с <o.length) 1 === о [с] .Нанесите (п [0], п [1]) && e.stopOnFalse && (с = o.length, п =! 1)} e.memory || (п =! 1), т =! 1, я && (о = n? []: "")}, l = {add: function () {return o && (n &&! t && (s = o.length-1, a.push (n)), функция t (n) {w. каждый (п, функция (п, г) {г (г) e.unique && l.has (г) || o.push (г):?! г && && r.length "строка" == х (г) && т (г) }}) (аргументы), п &&! т &&u ()), this}, remove: function () {return w.each (arguments, function (e, t) {var n; while ((n = w.inArray (t, o, n))> - 1 ) o.splice (n, 1), n ??<= s && s -}), имеет следующую функцию: function (e) {return e? w.inArray (e, o)> - 1: o.length> 0} , empty: function () {return o && (o = []), this}, disable: function () {return i = a = [], o = n = "", this}, disabled: function () {return ! o}, lock: function () {return i = a = [], n || t || (o = n = ""), this}, locked: function () {return !! i}, fireWith: функция (e, n) {return i || (n = [e, (n = n || []). slice? n.slice (): n], a.push (n), t || u ( )), this}, fire: function () {return l.fireWith (this, arguments), this}, fired: function () {return !! r}}; return l}; функция I (e) {return e } функция W (e) {throw e} функция $ (e, t, n, r) {var i; try {e && g (i = e.promise)? i.call (e) .done (t) .fail ( n): e && g (i = e.then)? i.call (e, t, n): t.apply (void 0, [e] .slice (r))} catch (e) {n.apply (void 0, [е])}} ш.extend ({Deferred: function (t) {var n = [[«уведомлять», «прогресс», w.Callbacks («память»), w.Callbacks («память»), 2], ["разрешить", " done ", w.Callbacks (" once memory "), w.Callbacks (" once memory "), 0," resolved "], [" reject "," fail ", w.Callbacks (" once memory "), w .Callbacks («once memory»), 1, «reject»]], r = «pending», i = {state: function () {return r}, always: function () {return o.done (arguments). fail (arguments), this}, "catch": function (e) {return i.then (null, e)}, pipe: function () {var e = arguments; return w.Deferred (function (t) {w .each (n, function (n, r) {var i = g (e [r [4]]) && e [r [4]]; o [r [1]] (function () {var e = i && i. ?. применить (это, аргументы); е && г (e.promise) e.promise () прогресс (t.notify) .done (t.resolve) .fail (t.reject):т [г [0] + "С"] (это, я [е]: аргументы).})}), е = NULL}) обещание ()}, то: функция (т, R, I) {вар o = 0; функция a (t, n, r, i) {return function () {var s = this, u = arguments, l = function () {var e, l, если (! (t <o)) {if ((e = r.apply (s, u)) === n.promise ()) запускает новый TypeError ("Thenable self-resolution"); l = e && ("object" == typeof e || " функция "== typeof e) && e. then, g (l)? i? l.call (e, a (o, n, I, i), a (o, n, W, i)): (o ++, l.call (е, а (о, п, I, I), а (O, N, W, I), а (о, п, я, n.notifyWith))) :( г! == I && ( s = void 0, u = [e]), (i || n.resolveWith) (s, u))}}, c = i? l: function () {try {l ()} catch (e) { w.eferred.exceptionHook && w.Deferred.exceptionHook (e, c.stackTrace), t + 1> = o && (r! == W && (s = void 0, u = [e]), n.rejectWith (s, u) )}}; t? c () :( w.Deferred.getStackHook && (c.stackTrace = w.Deferred.getStackHook ()), e.setTimeout (c))}} return w.Deferred (function (e) {n [0] [3].Добавить (а (0, е, г (I) I: I, e.notifyWith)), N [1] [3] .Add (? а (0, е, г (т) т: I)), n [2] [3] .add (a (0, e, g (r)? r: W))}). prom ()}, prom: function (e) {return null! = e? w.extend (e, i): i}}, o = {}; return w.each (n, function (e, t) {var a = t [2], s = t [5]; i [t [1] ] = a.add, с && a.add (функция () {г = s}, п [3-е] [2] .disable, п [3-е] [3] .disable, п [0] [2] .lock, n [0] [3] .lock), a.add (t [3] .fire), o [t [0]] = function () {return o [t [0] + "With"] (this === o? void 0: this, arguments), this}, o [t [0] + "With"] = a.fireWith}), i.promise (o), t && t.call (o, o ), o}, когда: function (e) {var t = arguments.length, n = t, r = Array (n), i = o.call (arguments), a = w.Deferred (), s = function (e) {return function (n) {r [e] = this, i [e] = arguments.length> 1? o.call (arguments): n, - t || a.resolveWith (r, i) }}, если (т <= 1 && ($ (е, a.done (с (п)) решения, a.reject, т), "до" === a.state () || г (I.! [n] && i [n]. then))) return a.then ();while (n -) $ (i [n], s (n), a.reject), return a.promise ()}}); var B = / ^ (Eval | Internal | Range | Reference | Синтаксис | Тип | URI) Ошибка $ /; w.Deferred.exceptionHook = function (t, n) {e.console && e.console.warn && t && B.test (t.name) && e.console.warn ("jQuery.Deferred exception:" + t. сообщение, t.stack, n)}, w.readyException = function (t) {e.setTimeout (function () {throw t})}; var F = w.Deferred (); w.fn.ready = function ( e) {return F.then (e) ["catch"] (function (e) {w.readyException (e)}), this}, w.extend ({isReady:! 1, readyWait: 1, ready: function (е) {(! 0 === е - w.readyWait: w.isReady) || (w.isReady = 0, 0 == е && - w.readyWait> 0 || F.resolveWith!! (r, [w]))}}, w.ready.then = F.then; function _ () {r.removeEventListener ("DOMContentLoaded", _), e.removeEventListener ("load", _), w .ready ()} "завершить" === r.readyState || "загрузки"! == г.readyState &&! r.documentElement.doScroll? e.setTimeout (w.ready) :( r.addEventListener («DOMContentLoaded», _), e.addEventListener («load», _)); var z = function (e, t, n, r, i, o, a) {var s = 0, u = e.length, l = null == n; if ("object" === x (n)) {i =! 0; для ( s в n) z (e, t, s, n [s], 0, o, a)} else if (void 0! == r && (i =! 0, g (r) || (a =! 0), l && (a? (T.call (e, r), t = null): (l = t, t = функция (e, t, n) {return l.call (w (e), n) })), т)) для (, s <и; s ++), т (е [с], п а р: r.call (е [с], с, т (е [с], п)) ), return i? e: l? t.call (e): u? t (e [0], n): o}, X = / ^ - ms - /, U = / - ([az]) / g, функция V (e, t) {return t.toUpperCase ()} функция G (e) {return e.replace (X, "ms -") заменить (U, V)} var Y = function (e) {return 1 === e.nodeType || 9 === e.nodeType ||! + e.nodeType}; функция Q () {this.expando = w.expando + Q.uid ++} Q.uid = 1, Q.prototype = {cache: function (e) {var t = e [this.expando]; return t || (t = {}, Y (e) && (e.NODETYPE е [this.expando] = т:? Object.defineProperty (е, this.expando, {значение: т, настраивается: 0}))), T}, установить: функция (е, т, п) {вар r, i = this.cache (e); if ("string" == typeof t) i [G (t)] = n; else для (r in t) i [G (r)] = t [r] ; return i}, get: function (e, t) {return void 0 === t? this.cache (e): e [this.expando] && e [this.expando] [G (t)]}, доступ : function (e, t, n) {return void 0 === t || t && "string" == typeof t && void 0 === n? this.get (e, t) :( this.set (e, t , n), void 0! == n? n: t)}, remove: function (e, tstring "== typeof t && void 0 === n? this.get (e, t) :( this.set (e, t, n), void 0! == n? n: t)}, remove: function ( е, тstring "== typeof t && void 0 === n? this.get (e, t) :( this.set (e, t, n), void 0! == n? n: t)}, remove: function ( е, т) {var n, r = e [this.expando]; if (void 0! == r) {if (void 0! == t) {n = (t = Array.isArray (t)? t.map ( G): (t = G (t)) в r? [T]: t.match (M) || []). Length, while (n -) delete r [t [n]]} (void 0 === t || w.isEmptyObject (r)) && (e.nodeType? e [this.expando] = void 0: удалить e [this.expando])}} hasData: function (e) {var t = e [this.expando]; return void 0! == t &&! w.isEmptyObject (t)}}; var J = new Q, K = new Q, Z = / ^ (?: \ {[\ w \ W] * \} | \ [[\ w \ W] * \]) $ /, ee = / [AZ] / g; функция te (e) {return "true" === e || "false"! == e && ("null" === e? null: e === + e + ""? + e: Z.test (e)? JSON.parse (e): e)} функция ne (e, t, n) {var r; if (void 0 === n && 1 === e.nodeType) if (r = "data -" + t.replace (ee, "- $ &"). toLowerCase (), "string" == typeof (n = e.getAttribute (r))) {try {n = te (n)} catch (e) {} K.set (e, t, n)} else n = void 0; return n} w. extend ({hasData: function (e) {return K.hasData (e) || J.hasData (e)}, data: function (e, t, n) {return K.access (e, t, n)}, removeData: function (e, t) {K.remove (e, t)}, _ data : function (e, t, n) {return J.access (e, t, n)}, _ removeData: function (e, t) {J.remove (e, t)}}), w.fn.extend ( {data: function (e, t) {var n, r, i, o = this [0], a = o && o.attributes; if (void 0 === e) {if (this.length && (i = K. получаем (о), 1 === o.nodeType && J.get (о, "hasDataAttrs"))) {п = a.length;!, а (п -) а [п] && 0 === (г = а [N] .name) .indexOf ( "данные -") && (R = G (r.slice (5)), п (о, г, я [г])); J.set (O, "hasDataAttrs" ,! 0)} return i} return "object" == typeof e? This.each (function () {K.set (this, e)}): z (this, function (t) {var n; if ( o && void 0 === t) {if (void 0! == (n = K.get (o, e))) return n; if (void 0! == (n = ne (o, e))) return n} else this.each (function () {K.set (this, e, t)})}, null, t, arguments.length> 1, null,! 0)}, removeData: function (e) {return это.каждый (функция () {K.remove (this, e)})}}), w.extend ({queue: function (e, t, n) {var r; if (e) возвращает t = (t || "FX") + "очереди", г = J.get (е, т), п && (! г || Array.isArray (п)? г = J.access (е, т, w.makeArray (п)) : r.push (n)), r || []}, dequeue: function (e, t) {t = t || "fx"; var n = w.queue (e, t), r = n. длина, я = n.shift (), о = w._queueHooks (е, т), а = функция () {w.dequeue (е, т)}; "InProgress" === я && (я = n.shift (), r -), i && ("fx" === t && n.unshift ("inprogress"), удалить o.stop, i.call (e, a, o)), r && o && o.empty.fire () }, _ queueHooks: function (e, t) {var n = t + "queueHooks"; return J.get (e, n) || J.access (e, n, {empty: w.Callbacks ("once memory") .add (function () {J.remove (e, [t + "queue", n])})})}}), w.fn.extend ({queue: function (e, t) {var n = 2 ; return "string"! = typeof e && (t = e, e = "fx", n--),arguments.length <n? w.queue (this [0], e): void 0 === t? this: this.each (function () {var n = w.queue (this, e, t); w ._queueHooks (this, e), "fx" === e && "inprogress"! == n [0] && w.dequeue (this, e)})}, dequeue: function (e) {return this.each (function () {w.dequeue (this, e)})}, clearQueue: function (e) {return this.queue (e || "fx", [])}, обещают: function (e, t) {var n , г = 1, г = w.Deferred (), о = это, а = this.length, с = функция () {- г || i.resolveWith (о, [о])}; "строка"! = typeof e && (t = e, e = void 0), e = e || "fx", тогда как (a -) (n = J.get (o [a], e + "queueHooks")) && n.empty && (r ++, n.empty.add (s)); return s (), i.promise (t)}}); var re = / [+ -]? (?: \ d * \. |) \ d + ( ?: [eE] [+ -]? \ d + |) /. source, ie = new RegExp ("^ (?: ([+ -]) = |) (" + re + ") ([az%] *) $», "я"), ае = [ "Вверх", "Вправо", "Вниз", "влево"], А е = функция (е, т) {возвращение "нет" === (е = т || е) .style.display || "" === e.style.display && w.contains (e.ownerDocument, е ) && "none" === w.css (e, "display")}, se = function (e, t, n, r) {var i, o, a = {}, для (o в t) a [o] = e.style [o], e.style [o] = t [o]; i = n.apply (e, r || []), для (o в t) e.style [o] = a [o]; return i}; функция u (e, t, n, r) {var i, o, a = 20, s = r? function () {return r.cur ()}: function () {return w.css (e, t, "")}, u = s (), l = n && n [3] || (w.cssNumber [t]? "": "px"), c = (w. ! cssNumber [т] || "ПВ" == && л + и) && ie.exec (w.css (е, т));!, если (с && с [3] == л) {и / = 2, L = L || с [3], с = + и || 1, в то время (а -) w.style (е, т, с + л), (1-о) * (1- (O = S () / u || .5)) <= 0 && (a = 0), c / = o; c * = 2, w.style (e, t, c + l), n = n || []} return n && ( с = + с + || и || 0, г = п [1] с + (п [1] + 1) * п [2]: + п [2], г && (r.unit = л, г. start = c, r.end = i)), i} var le = {};функция ce (e) {var t, n = e.ownerDocument, r = e.nodeName, i = le [r]; return i || (t = n.body.appendChild (n.createElement (r)), i = w.css (t, "display"), t.parentNode.removeChild (t), "none" === i && (i = "block"), le [r] = i, i)} функция fe (e , t) {для (var n, r, i = [], o = 0, a = e.length; o <a; o ++) (r = e [o]). style && (n = r.style.display , т? ( "нет" === п && (я [о] = J.get (г, "дисплей") || нуль, я [о] || (r.style.display = "")),» "=== r.style.display && ая (г) && (я [о] = с (г))):" нет "! == п && (я [о] =" нет "J.set (г," display ", n))); for (o = 0; o <a; o ++) null! = i [o] && (e [o] .style.display = i [o]); return e} w.fn .extend ({show: function () {return fe (this,! 0)}, hide: function () {return fe (this)}, toggle: function (e) {return "boolean" == typeof e? e ? this.show (): this.hide (): это.каждый (функция () {ae (this)? w (this) .show (): w (this) .hide ()})}}; var pe = / ^ (?: checkbox | radio) $ / i, де = / <([AZ] [^ \ / \ 0> \ x20 \ т \ г \ п \ е] +) / я, он = / ^ $ | ^ модуль $ | \ / (?: Java | ECMA) script / i, ge = {option: [1, "<select multiple = 'multiple'>", "</ select>"], thead: [1, "<table>", "</ table>"], Col: [2, "<таблица> <COLGROUP>", "</ COLGROUP> </ таблицы>"], тр: [2, "<таблица> <TBODY>", "</ TBODY> </ таблицы>" ], тд: [3, "<таблица> <TBODY> <TR>", "</ TR> </ TBODY> </ таблицы>"] _ по умолчанию: [0, "", ""]}; GE. optgroup = ge.option, ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td; функция ye (e, t) {var n; return n = "undefined "! = typeof e.getElementsByTagName? e.getElementsByTagName (t || "*"): "undefined"! = typeof e.querySelectorAll? e.querySelectorAll (t || "*"): [], void 0 === t || t && N (e, t)? w.merge ([e], n): n} функция ve (e, t) {для (var n = 0, r = e.length; n <r; n ++) J.set (e [n], " globalEval ",! t || J.get (t [n]," globalEval "))} var me = / <| & #? \ w +; /; функция xe (e, t, n, r, i) { для (var o, a, s, u, l, c, f = t.createDocumentFragment (), p = [], d = 0, h = e.length; d <h; d ++), если ((o = e [d]) || 0 === o) if ("object" === x (o)) w.merge (p, o.nodeType? [o]: o); else if (me.test (o )) {а = || f.appendChild (t.createElement ( "DIV")), с = (de.exec (о) || [ "", ""]) [1] .toLowerCase (и), и = GE [с] || ge._default, a.innerHTML = и [1] + w.htmlPrefilter (о) + и [2], с = и [0], в то время (с -) а = a.lastChild ; w.merge (p, a.childNodes), (a = f.firstChild) .textContent = ""} else p.push (t.createTextNode (o)); f.textContent = "",d = 0, тогда как (o = p [d ++]), если (r && w.inArray (o, r)> - 1) i && i.push (o); else if (l = w.contains (o.ownerDocument, o) а = вы (f.appendChild (о), "сценарий"), л && ве (а), п) {с = 0, в то время (о = [C ++]) he.test (o.type || "") && п .push (o)} return f}! function () {var e = r.createDocumentFragment (). appendChild (r.createElement ("div")), t = r.createElement ("input"); t.setAttribute ( "тип", "радио"), t.setAttribute ( "проверено", "проверено"), t.setAttribute ( "название", "T"), e.appendChild (т), h.checkClone = e.cloneNode ( ! 0) .cloneNode (0) .lastChild.checked, e.innerHTML = "<TextArea> х </ TextArea>", h.noCloneChecked = !! e.cloneNode (0) .lastChild.defaultValue} ()!!; var be = r.documentElement, we = / ^ key /, Te = / ^ (?: mouse | указатель | contextmenu | drag | drop) | click /, Ce = / ^ ([^.] *) (?: \ .) / | (+.);функция Ee () {return! 0} функция ke () {return! 1} Se () {try {return r.activeElement} catch (e) {}} функция De (e, t, n, r, i, o) {var a, s; if ("object" == typeof t) {"string"! = typeof n && (r = r || n, n = void 0), для (s в t) De (e, s, n, r, t [s], o); return e} if (null == r && null == i? (i = n, r = n = void 0): null == i && ("string" == typeof n? (i = r, r = void 0) :( i = r, r = n, n = void 0)), 1 = i) i = ke; else if (! i) return e; return 1 === o && (a = i, (i = function (e) {return w (). off (e), a.apply (this, arguments)}). guid = a.guid || (a. GUID = w.guid ++)), e.each (функция () {w.event.add (это, T, I, г, п)})} = {w.event глобальный: {}, добавьте: функцию (е , t, n, r, i) {var o, a, s, u, l, c, f, p, d, h, g, y = J.get (e), если (y) {n.handler && (п = (о = п) .handler, я = o.selector), я && w.find.matchesSelector (быть, я), n.guid || (n.guid = w.guid ++), (и = y.events ) || (и = y.events = {}), (а = y.handle) || (а = у.handle = function (t) {return "undefined"! = typeof w && w.event.triggered! == t.type? w.event.dispatch.apply (e, arguments): void 0}), l = (t = ( т || "".) совпадают (М) || [ ""]) длина;., а (л -) д = г = (s = Ce.exec (т [л]) || []) [1 ], ч = (с [2] || ""). сплит ( "".). рода (), д && (е = w.event.special [d] || {}, д = (я? ф. delegateType: f.bindType) || д, е = w.event.special [d] || {}, с = w.extend ({тип: д, OrigType: г, данные: г, обработчик: п, GUID: n.guid, селектор: я, needsContext: я && w.expr.match.needsContext.test (я), пространство имен: h.join ( "")}, о), (р = и [d]) || (( р = и [d] = []). delegateCount = 0, f.setup &&! 1! == f.setup.call (е, г, д, а) || e.addEventListener && e.addEventListener (д, а)) , f.add && (f.add.call (е, с), c.handler.guid || (c.handler.guid = n.guid)), я? p.splice (p.delegateCount ++, 0, с) : p.push (c), w.event.global [d] =! 0)}}, remove: function (e, t, n, r, i) {var o, a, s,U, L, C, F, р, д, ч, г, у = J.hasData (е) && J.get (е), если (у && (и = y.events)) {л = (т = (т || "".) совпадают (М) || [ ""]) длина;., а (л -), если (s = Ce.exec (т [л]) || [], д = г = с [ 1], H = (s [2] || ""). сплит ( ""). рода (в), г) {е = w.event.special [d] || {}, р = и [д = (r? f.delegateType: f.bindType) || d] || [], s = s [2] && new RegExp ("(^ | \\.)" + h.join ("\\. (? .: * \\ |) ") +" (\\ | $) "), а = о = p.length, в то время как (о -) с = р [о] ,! я && г == с..!. !! OrigType || п && n.guid == c.guid || s && s.test (c.namespace) || г && г == c.selector && ( "**" == г || c.selector!) | !! | (p.splice (о, 1), c.selector && p.delegateCount -, f.remove && f.remove.call (е, с)); && p.length && (f.teardown && 1 == f.teardown .call (e, h, y.handle) || w.removeEvent (e, d, y.handle), delete u [d])} else для (d в u) w.event.remove (e, d + т [л], п, г, 0);! ш.isEmptyObject (u) && J.remove (e, "handle events")}}, dispatch: function (e) {var t = w.event.fix (e), n, r, i, o, a, s, u = new Array (arguments.length), l = (J.get (это, «события») || {}) [t.type] || [], c = w.event.special [t.type] | | {}; для (и [0] = т, п = 1, п <arguments.length, п ++) и [п] = аргументы [п], если (t.delegateTarget = это, c.preDispatch ||! ! 1 == c.preDispatch.call (это, т)) {s = w.event.handlers.call (это, т, л), п = 0, тогда как ((O = s [N ++]) && т! .isPropagationStopped ()) {t.currentTarget = o.elem, г = 0;! в то время как ((а = o.handlers [г ++]) && t.isImmediatePropagationStopped ()) t.rnamespace && t.rnamespace.test (а!. пространство имен) || (t.handleObj = a, t.data = a.data, void 0! == (i = ((w.event.special [a.origType] || {}). handle || a. обработчик) .apply (o.elem, u)) &&! 1 === (t.result = i) && (t.preventDefault (), t.stopPropagation ()))} return c.postDispatch && c.postDispatch.call ( это, т), т.result}}, обработчики: function (e, t) {var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType &&! ("click "=== e.type && e.button> = 1)) для (;! л == это, л = l.parentNode || это), если (1 === l.nodeType && (" нажмите "== е!. type ||! 0! == l.disabled)) {for (o = [], a = {}, n = 0; n <u; n ++) void 0 === a [i = (r = t [ n]). selector + ""] && (a [i] = r.needsContext? w (i, this) .index (l)> - 1: w.find (i, this, null, [l]). length ), a [i] && o.push (r); o.length && s.push ({elem: l, обработчики: o})} return l = this, u <t.length && s.push ({elem: l, обработчики: t.slice (и)}), s}, addProp: функция (е, т) {Object.defineProperty (w.Event.prototype, е, {перечислимы: 0, конфигурируемый: 0, получаем: г (т) ? function () {if (this.originalEvent) return t (this.originalEvent)}: function () {if (this.originalEvent) возвращает this.originalEvent [e]}, set: function (t) {Object.defineProperty ( это,e, {enumerable:! 0, configurable:! 0, writeable:! 0, value: t})}})}, fix: function (e) {return e [w.expando]? e: new w.Event ( e)}, special: {load: {noBubble:! 0}, focus: {trigger: function () {if (this! == Se () && this.focus) return this.focus () ,! 1}, delegateType : "focusin"}, blur: {trigger: function () {if (this === Se () && this.blur) return this.blur () ,! 1}, delegateType: "focusout"}, click: {trigger : function () {if ("checkbox" === this.type && this.click && N (this, "input")) return this.click () ,! 1}, _ default: function (e) {return N (e.target , "a")}}, beforeunload: {postDispatch: function (e) {void 0! == e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)}}}}, w.removeEvent = function ( e, t, n) {e.removeEventListener && e.removeEventListener (t, n)}, w.Event = function (e, t) {if (! (этот экземпляр w.Событие)) возвращает новый w.Event (e, t); e && e.type? (This.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !? 1 === e.returnValue Ee: KE, this.target = e.target && 3 === e.target.nodeType e.target.parentNode: e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget): this.type = е, т && w.extend (это, т), this.timeStamp = е && e.timeStamp || Date.now (), это [w.expando] = 0}, w.Event! .prototype = {constructor: w.Event, isDefaultPrevented: ke, isPropagationStopped: ke, isImmediatePropagationStopped: ke, isSimulated:! 1, preventDefault: function () {var e = this.originalEvent; this.isDefaultPrevented = Ee, e &&! this. isSimulated && e.preventDefault ()}, stopPropagation: function () {var e = this.originalEvent; this.isPropagationStopped = Ee, e &&! this.isSimulated && e.stopPropagation ()}, stopImmediatePropagation: function () {var e = this.originalEvent; this.isImmediatePropagationStopped = Ee, e &&! this.isSimulated && e.stopImmediatePropagation (), this.stopPropagation ()}}, w.each ({altKey :! 0, пузыри: 0, нерасторгаемым: 0, changedTouches: 0, ctrlKey: 0, деталь: 0, EventPhase: 0, metaKey: 0, pageX: 0, Пейджи: 0, shiftKey :! 0, вид: 0, "символ": 0, charCode: 0, ключ: 0, KEYCODE: 0, кнопка:! 0, кнопки: 0, clientX: 0, clientY: 0, OffsetX : 0, OffsetY: 0, pointerId: 0, pointerType: 0, ScreenX: 0, Screeny: 0, targetTouches: 0, toElement: 0, прикасается: 0, что: функция (е) {var t = e.button; return null == e.which && we.test (e.type)? null! = e.charCode? e.charCode: e.keyCode:! e.which && void 0! == t && Te.test ( ? e.type) 1 & т 1: 2 & т 3:? 4 & т 2: 0: e.which}}, w.event.addProp), w.each ({MouseEnter: "Mouseover", MouseLeave:»mouseout ", pointerenter:" pointerover ", pointerleave:" pointerout "}, function (e, t) {w.event.special [e] = {delegateType: t, bindType: t, handle: function (e) {var n , r = this, i = e.relatedTarget, o = e.handleObj; return i && (i === r || w.contains (r, i)) || (e.type = o.origType, n = o (this, arguments), e.type = t), n}}}), w.fn.extend ({on: function (e, t, n, r) {return De (this, e, t, n, r)}, one: function (e, t, n, r) {return De (this, e, t, n, r, 1)}, off: function (e, t, n) {var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, w (e.delegateTarget) .off (r.namespace? r.origType + "." + r.namespace: r.origType, r.selector , r.handler), this: if ("object" == typeof e) {для (i в e) this.off (i, t, e [i]); return this} return! 1! == t && " function () = typeof t || (n = t, t = void 0), 1 1 = n && (n = ke), this.each (function () {w.event.remove (this, e, n ,t)})}}); var Ne = / <(| area | br | col | embed | hr | img | input | link | meta | param) (([az] [^ \ / \ 0> \ x20 \ т \ г \ п \ е] *) [^>] *) \ /> / ги, Ae = / <сценарий | <стиль | <ссылка / я, JE = / проверено \ с * (: [^ =? .] | = \ с * .Checked) / я, QE = / ^ \ с * <(: \ [CDATA \ [| -) | (?: \!]? \] | -)> \ s * $ / g; функция Le (e, t) {return N (e, "table") && N (11! == t.nodeType? t: t.firstChild, "tr")? w (e) .children (" tbody ") [0] || e: e} function He (e) {return e.type = (null! == e.getAttribute (" type ")) +" / "+ e.type, e} function Oe (е) {возвращение "истина /" === (e.type || "") срез (0,5) e.type = e.type.slice (5):.? e.removeAttribute ( "тип") , e} функция Pe (e, t) {var n, r, i, o, a, s, u, l, если (1 === t.nodeType) {if (J.hasData (e) && (o = J.access (e), a = J.set (t, o), l = o.events)) {delete a.handle, a.events = {}; для (i в l) для (n = 0 , г = л [я] .length; п <г; п ++) w.event.add (т, I, L [я] [п])} K.hasData (е) && (s = K.access (e), u = w.extend ({}, s), K.set (t, u))}} функция Me (e, t) {var n = t.nodeName.toLowerCase ?! (); "вход" === п && pe.test (e.type) t.checked = e.checked: "вход" == п && "TextArea" == п || (t.defaultValue = e.defaultValue )} функция Re (e, t, n, r) {t = a.apply ([], t); var i, o, s, u, l, c, f = 0, p = e.length, d = p-1, y = t [0], v = g (y), если (v || p> 1 && "string" == typeof y &&! h.checkClone && je.test (y)) return e.each (function (i) {var o = e.eq (i); v && (t [0] = y.call (это, i, o.html ())), Re (o, t, n, r)}); если (р && (я = х (т, е [0] .ownerDocument,! 1, е, г), о = i.firstChild, 1 === i.childNodes.length && (я = о), о || г .)) {для (и = (ы = w.map (вы (я, "сценарий"), он)) длина; е <р;! е ++) л = I, F == д && (л = w.clone (л, 0, 0!!), у && w.merge (с, вы (л, "сценарий"))), n.call (е [е], L, F), если (и) для (с = ы [s.length-1] .ownerDocument, w.map (с, э),F = 0, е <и, е ++) л = с [е], he.test (l.type || ""!) && J.access (л, "globalEval") && w.contains (с, л) && (l.src && "модуль" == (l.type || "!") toLowerCase () w._evalUrl && w._evalUrl (l.src).? м (l.textContent.replace (QE, ""), с , l))} return e} функция Ie (e, t, n) {для (var r, i = t? w.filter (t, e): e, o = 0; null! = (r = i [ о]!), о ++) п || 1 == r.nodeType || w.cleanData (вы (г)), r.parentNode && (п && w.contains (r.ownerDocument, г) && ве (вы (г, "сценарий ")), r.parentNode.removeChild (r)); return e} w.extend ({htmlPrefilter: function (e) {return e.replace (Ne," <$ 1> </ $ 2> ")}, клон: функция (e, t, n) {var r, i, o, a, s = e.cloneNode (! 0), u = w.contains (e.ownerDocument, e), если (! (h.noCloneChecked || !! 1 == e.nodeType && 11 == e.nodeType || w.isXMLDoc (е))) для (а = уе (ы), г = 0, г = (о = у ^ (е)) длины; г. <я; г ++), М (о [г],а [г]); если (т), если (п) при (о = о || вы (е), а = || вы (ы), г = 0, г = o.length; г <я; r ++) Pe (o [r], a [r]), еще Pe (e, s); return (a = ye (s, "script")). length> 0 && ve (a,! u && ye (e, "script ")), s}, cleanData: function (e) {for (var t, n, r, i = w.event.special, o = 0; void 0! == (n = e [o]); o ++ ) if (Y (n)) {if (t = n [J.expando]) {если (t.events) для (r в t.events) i [r]? w.event.remove (n, r) : w.removeEvent (n, r, t.handle); n [J.expando] = void 0} n [K.expando] && (n [K.expando] = void 0)}}}), w.fn .extend ({detach: function (e) {return Ie (this, e,! 0)}, remove: function (e) {return Ie (this, e)}, text: function (e) {return z (this , function (e) {return void 0 === e? w.text (this): this.empty (). each (function () {1! == this.nodeType && 11! == this.nodeType && 9! == this .nodeType || (this.textContent = e)})}, null, e, arguments.length)}, append: function () {return Re (this, arguments, function (e) {1! == this.nodeType && 11 !== this.nodeType && 9! == this.nodeType || Le (this, e) .appendChild (e)})}, prepend: function () {return Re (это, аргументы, функция (e) {if (1 = == this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = Le (this, e); t.insertBefore (e, t.firstChild)}})}, before: function () {return Re (this, arguments, function (e) {this.parentNode && this.parentNode.insertBefore (e, this)})} после: function () {return Re (this, arguments, function (e ) {this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)})}, empty: function () {for (var e, t = 0; null! = (e = this [t]); t ++) 1 === e.nodeType && (w.cleanData (ye (e,! 1)), e.textContent = ""); return this}, clone: ??function (e, t) {return e = null! = e && e, t = null == t? e: t, this.map (function () {return w.clone (this, e, t)})}, html: function (e) {return z (this, function (e) { var t = this [0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t.nodeType) return t.innerHTML; if ("string" == typeof e &&! Ae.test (e) &&! ge [(de.exec (e) || ["", ""]) [1] .toLowerCase ( )]) {е = w.htmlPrefilter (е); попытаться {для (; п <г;. п ++), 1 === (т = это [п] || {}) NODETYPE && (w.cleanData (вы (т !, 1)), t.innerHTML = е); T = 0} поймать (е) {}} т && this.empty () добавление (е)}, нуль, е, arguments.length)}, ReplaceWith: функция (. ) {var e = []; return Re (this, arguments, function (t) {var n = this.parentNode; w.inArray (this, e) <0 && (w.cleanData (ye (this)), n && n. replaceChild (т, это))}, е)}}), w.each ({appendTo: "добавить", prependTo: "" добавьте в начале InsertBefore: "до", InsertAfter: "после", replaceAll: "ReplaceWith"} , функция (e, t) {w.fn [e] = function (e) {для (var n, r = [], i = w (e), o = i.length-1, a = 0; a <= о; A ++) п = а === о это: (! 0), ш (я [а]) [т] (п), s.apply (г, n.get () this.clone) , верните это.pushStack (r)}}); var We = новый RegExp ("^ (" + re + ") (?! px) [az%] + $", "i"), $ e = function (t) {var n = t.ownerDocument.defaultView; return n && n.opener || (n = e), n.getComputedStyle (t)}, Be = новый RegExp (oe.join ("|"), "i") ;! function () {function t () {if (c) {l.style.cssText = "position: absolute; left: -11111px; width: 60px; margin-top: 1px; padding: 0; border: 0", c.style. cssText = "положение: относительная; дисплей: блок; коробчатого проклейки: границы коробки; переполнения: прокрутки; поле: автоматическая; границы: 1px; обивка: 1px; ширина: 60%; сверху: 1%", be.appendChild ( l) .appendChild (c); var t = e.getComputedStyle (c); i = "1%"! == t.top, u = 12 === n (t.marginLeft), c.style.right = "60%", s = 36 === N (t.right), O = 36 === п (t.width), c.style.position = "абсолютный", а = 36 === c.offsetWidth || "absolute", be.removeChild (l), c = null}} function n (e) {return Math.round (parseFloat (e))} var i, o, a, s, u, l = r.createElement ("div"), c = r.createElement ("div"); c.style && (c.style.backgroundClip = "содержание ящика", c.cloneNode .style.backgroundClip = "", h.clearCloneStyle = "содержание ящика" === c.style.backgroundClip, w.extend (Л, {boxSizingReliable (0!): функция () {return t (), o}, pixelBoxStyles: function () {return t (), s}, pixelPosition: function () {return t (), i}, reliableMarginLeft: function () {return t (), u}, scrollboxSize: function () {return t (), a}}))} (); функция Fe (e, t, n) {var r, i, o, a, s = e.style; return ( п = п || $ е (е)) && ( ""! == (а = n.getPropertyValue (т) || п [т]) || w.contains (e.ownerDocument, е) || (а = w.style (е, т)) ,! h.pixelBoxStyles () && We.test (а) && Be.test (т) && (г = s.width, я = s.minWidth, о = s.maxWidth, с .minWidth = s.maxWidth = s.width = а, а = n.width, s.width = г, s.minWidth = я, с.maxWidth = o)), void 0! == a? a + "": a} function _e (e, t) {return {get: function () {if (! e ()) return (this.get = t) .apply (this, arguments); delete this.get}}} var ze = / ^ (none | table (?! - c [ea]). +) /, Xe = / ^ - /, Ue = {позиция : "абсолютный", видимость: "скрытый", дисплей: "блок"}, Ve = {letterSpacing: "0", FontWeight: "400"}, Ge = [ "Webkit", "Мос", "мс"], Ye = r.createElement ("div"). Style; function Qe (e) {if (e в Ye) возвращает e; var t = e [0] .toUpperCase () + e.slice (1), n ??= Ge (1), если ((e = Ge [n] + t) в Ye) возвращает e} функцию Je (e) {var t = w.cssProps [e]; return t || (t = w.cssProps [e] = Qe (e) || e), t} функция Ke (e, t, n) {var r = ie.exec (t); return r? Math.max (0, r [2 ] - (n || 0)) + (r [3] || "px"): t} функция Ze (e, t, n, r, i, o) {var a = "width" === t ? 1: 0, s = 0, u = 0, если (n === (r? "Border": "content")) return 0; for (;а <4; а + = 2) "запас" === п && (и + = w.css (е, п + ае [а] ,! 0, я)), г ( "содержание" === п && (и? - = w.css (е, "набивка" + ае [а] ,! 0, я)), "маржа" == п && (u- = w.css (е, "граница" + ае [а] +! "Ширина",! 0, я))) :( и + = w.css (е, "заполнение" + ае [а] ,! 0, я), "заполнение"! == п? и + = w.css ( ! е, "граница" + ае [а] + "Ширина", 0, я): s + = w.css (е, "граница" + ае [а] + "Ширина", 0, я)); возвращение! ! г && о> = 0 && (и + = Math.max (0, Math.ceil (е [ "смещение" + T [0] .toUpperCase () + t.slice (1)] - 0,5-ОЕ))), U } функция et (e, t, n) {var r = $ e (e), i = Fe (e, t, r), o = "border-box" === w.css (e, "boxSize" ,! 1, r), a = o, если (We.test (i)) {if (! N) возвращает i; i = "auto"} return a = a && (h.boxSizingReliable () || i == = e.style [т]), ( "авто" === я ||! parseFloat (я) && "инлайн" === w.css (е,"Дисплей",! 1, г)) && (я = е [ "смещение" + T [0] .toUpperCase () + t.slice (1)], а =! 0), (я = parseFloat (я) || 0) + З (е, т, п || (о "граница": "содержание"), а, г, я) + "ПВ"} w.extend ({cssHooks: {непрозрачность: {получает: функция (e, t) {if (t) {var n = Fe (e, "opacity"), return "" === n? "1": n}}}}, cssNumber: {animationIterationCount:! 0, ColumnCount: 0, fillOpacity: 0, flexGrow: 0, flexShrink: 0, FontWeight: 0, LineHeight: 0, непрозрачность: 0, заказ: 0, дети-сироты: 0, вдовы: 0, zIndex:! 0, zoom:! 0}, cssProps: {}, style: function (e, t, n, r) {if (e && 3! == e.nodeType && 8! == e.nodeType && e.style) {var i , о, а, с = о (т), и = Xe.test (т), л = e.style; если (и || (т = Je (ы)), а = w.cssHooks [т] | | w.cssHooks [s], void 0 === n) возвращает a && "get" в && void 0! == (i = a.get (e,! 1, r))? i: l [t]; " string "== (o = typeof n) && (i = ie.exec (n)) &&я [1] && (п = ие (е, т, я), о = "число"), нуль! = п && п === п && ( "число" === о && (п + = я && я [3] || ( w.cssNumber [с] "?": "! точек")), h.clearCloneStyle || "" == п || 0 == t.indexOf ( "фон") || (л [т] =» наследовать "), &&" set "в && void 0 === (n = a.set (e, n, r)) || (u? l.setProperty (t, n): l [t] = n)) }}, css: function (e, t, n, r) {var i, o, a, s = G (t); return Xe.test (t) || (t = Je (s)), (a = w.cssHooks [t] || w.cssHooks [s]) && "get" в && (i = a.get (e,! 0, n)), void 0 === i && (i = Fe (e , t, r)), "normal" === i && t в Ve && (i = Ve [t]), "" === n || n? (o = parseFloat (i) ,! 0 === n | | isFinite (O) O || 0: I):}}), w.each ([ "высота", "ширина"], функция (е, т) {w.cssHooks [т] = {получаем: функция (е, п, г) {если (п) вернуться! ze.test (w.css (е, "дисплей")) || е... GetClientRects () Длина && e.getBoundingClientRect () ширина и др (д, т, г): с (е, Ue, функция () {вернуться ET (е, т, г)})}, установить: функцию (е, n, r) {var i, o = $ e (e), a = "border-box" === w.css (e, "boxSize",! 1, o), s = r && Ze (e, t, r, a, o); return a && h.scrollboxSize () === o.position && (s- = Math.ceil (e ["offset" + t [0] .toUpperCase () + t.slice (1)] - parseFloat (о [т]) - Зе (е, т, "граница", 1, о!) -. 5)), с && (я = ie.exec (п)) && "точек" == (я [! 3] || "ПВ") && (e.style [т] = п, п = w.css (е, т)), Ка (е, п, з)}}}), w.cssHooks.marginLeft = _e (h.reliableMarginLeft, функция (е, т) {если (т) возвращение (parseFloat (Fe (е, "MarginLeft")) || e.getBoundingClientRect () слева-се (е, {MarginLeft:. 0}, function () {return e.getBoundingClientRect (). left})) + "px"}), w.each ({margin: "", padding: "", border: "Width"},функция (e, t) {w.cssHooks [e + t] = {expand: function (n) {for (var r = 0, i = {}, o = "string" == typeof n? n.split ( ""): [n]; r <4; r ++) i [e + oe [r] + t] = o [r] || o [r-2] || o [0]; return i}}, «margin»! == e && (w.cssHooks [e + t] .set = Ke)}), w.fn.extend ({css: function (e, t) {return z (this, function (e, t , n) {var r, i, o = {}, a = 0, если (Array.isArray (t)) {для (r = $ e (e), i = t.length, a <i; a ++) o [t [a]] = w.css (e, t [a] ,! 1, r); return o} return void 0! == n? w.style (e, t, n): w.css (e, t)}, e, t, arguments.length> 1)}}), функция tt (e, t, n, r, i) {return new tt.prototype.init (e, t, n, r , я)} w.Tween = тт, tt.prototype = {конструктор: тт, INIT: функция (е, т, п, г, I, O) {this.elem = е, this.prop = п, это. ослабление = I || w.easing._default, this.options = т, this.start = this.now = this.cur (), this.end = г, this.unit = о || (w.cssNumber [п ]? "": "px")}, cur: function () {var e = tt.propHooks [this.prop]; return e && e.get? e.получить (это): tt.propHooks._default.get (это)}, запустить: функцию (е) {уаг т, п = tt.propHooks [this.prop]; возвратить this.options.duration this.pos = т = w.easing [this.easing] (е, е * this.options.duration, 0,1, this.options.duration): this.pos = т = е, this.now = (this.end-это. старт) * T + this.start, this.options.step && this.options.step.call (this.elem, this.now, это), п && n.set n.set (это): tt.propHooks._default.set (это), это}}, tt.prototype.init.prototype = tt.prototype, tt.propHooks = {_ по умолчанию: {получить: функция (е) {уаг т; возвращает 1 == e.elem.nodeType || нуль! = e.elem [e.prop] && NULL == e.elem.style [e.prop]? e.elem [e.prop] :( т = w.css (e.elem, e.prop» ")) &&" авто "== т т:? 0}, набор: функция (е) {w.fx.step [e.prop] w.fx.step [e.prop] (е): 1 ! == e.elem.nodeType || нуль == e.elem.style [w.cssProps [e.prop]] &&! w.cssHooks [e.prop]? e.elem [e.prop] = е. Сейчас: w.style (e.elem, e.prop, д.теперь + e.unit)}}}, tt.propHooks.scrollTop = tt.propHooks.scrollLeft = {множество: функция (е) {e.elem.nodeType && && e.elem.parentNode (e.elem [e.prop] = е .)}}, w.easing = {linear: function (e) {return e}, swing: function (e) {return.5-Math.cos (e * Math.PI) / 2}, _ default: " swing "}, w.fx = tt.prototype.init, w.fx.step = {}; var nt, rt, it = / ^ (?: toggle | show | hide) $ /, ot = / queueHooks $ / ; function at () {rt && (! 1 === r.hidden && e.requestAnimationFrame? e.requestAnimationFrame (at): e.setTimeout (at, w.fx.interval), w.fx.tick ())} function st () {return e.setTimeout (function () {nt = void 0}), nt = Date.now ()} function ut (e, t) {var n, r = 0, i = {height: e}; для (t = t? 1: 0; r <4; r + = 2-t) i ["margin" + (n = oe [r])] = i ["padding" + n] = e; return t && ( i.opacity = i.width = e), i} функция lt (e, t, n) {для (var r, i = (pt.tweeners [t] || []). concat (pt.tweeners [" * "]), о = 0, а = i.length; о <а;o ++) if (r = i [o] .call (n, t, e)) возвращает r} функцию ct (e, t, n) {var r, i, o, a, s, u, l, c, f = «ширина» по t «высота» по t, p = это, d = {}, h = e.style, g = e.nodeType && ae (e), y = J.get (e, "fxshow" );. n.queue || (нуль == (а = w._queueHooks (е, "FX")) unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty.fire = функция ( ) {a.unqueued || с ()}), a.unqueued ++ p.always (функция () {p.always (функция () {a.unqueued -, w.queue (е, "FX"). length: a.empty.fire ()})})), для (r в t), если (i = t [r], it.test (i)) {if (delete t [r], o = o || "toggle" === i, i === (g? "hide": "show")) {if ("show"! == i ||! y || void 0 === y [r ]) продолжить;! г = 0} d [г] = у && у [г] || w.style (е, г)}, если ((и = w.isEmptyObject (т)!) || w.isEmptyObject (д! )) {е && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], нуль == (л = у && y.display) && (л = J.get (е,"Дисплей")), "нет" === (с = w.css (е, "дисплей")) && (л с = л: (Fe ([е] ,! 0), л = e.style .display || л, с = w.css (е, "дисплей"), Fe ([е]))), ( "встроенный" === с || "встроенный блок" === с нулевым &&! = л ) && "нет" === w.css (е, "плавать") && (и || (p.done (функция () {h.display = л}), нуль == л && (с = h.display , л = "нет" === с "?": с)), h.display = "встроенный блок")), n.overflow && (h.overflow = "скрытый", p.always (функция () { h.overflow = n.overflow [0], h.overflowX = n.overflow [1], h.overflowY = n.overflow [2]})), u =! 1, для (r в d) u || (y? "hidden" в y && (g = y.hidden): y = J.access (e, "fxshow", {display: l}), o && (y.hidden =! g), g && fe ([e] , (0), p.done (function () {g || fe ([e]), J.remove (e, "fxshow"), для (r в d) w.style (e, r, d [ ? г])})), и = л (г у [г]: 0,r, p), r в y || (y [r] = u.start, g && (u.end = u.start, u.start = 0))}} функция ft (e, t) {var n, r, i, o, a, для (n в e), если (r = G (n), i = t [r], o = e [n], Array.isArray (o) && (i = o [1 ], o = e [n] = o [0]), n! == r && (e [r] = o, delete e [n]), (a = w.cssHooks [r]) && "expand" в a) {o = a.expand (o), delete e [r]; для (n в o) n в e || (e [n] = o [n], t [n] = i)} else t [r] = i} функция pt (e, t, n) {var r, i, o = 0, a = pt.prefilters.length, s = w.Deferred (). always (function () {delete u. elem}), u = function () {if (i) return! 1, для (var t = nt || st (), n = Math.max (0, l.startTime + l.duration-t), r = 1 (n / l.duration || 0), o = 0, a = l.tweens.length; o <a; o ++) l.tweens [o] .run (r); return s.notifyWith (e , [л, г, п]), г <1 && н: (а || s.notifyWith (е, [л, 1,0]), s.resolveWith (е, [л]) ,! 1)} , л = s.promise ({эль: е, реквизит: w.extend ({}, т), выбирает: w.extend (0, {specialEasing: {}, ослабление: w.easing._default}, п) , originalProperties: T, originalOptions: н,startTime: nt || st (), duration: n.duration, twenens: [], createTween: function (t, n) {var r = w.Tween (e, l.opts, t, n, l.opts. specialEasing [t] || l.opts.easing); return l.tweens.push (r), r}, stop: function (t) {var n = 0, r = t? l.tweens.length: 0; if (i) вернуть это: for (i =! 0; n <r; n ++) l.tweens [n] .run (1); return t? (s.notifyWith (e, [l, 1,0]) , s.resolveWith (е, [L, T])): s.rejectWith (е, [L, T]), это}}), C = l.props; для (фут (с, l.opts.specialEasing ), o <a; o ++), если (r = pt.prefilters [o] .call (l, e, c, l.opts)) return g (r.stop) && (w._queueHooks (l.elem, l .opts.queue) .stop = r.stop.bind (r)), r; return w.map (c, lt, l), g (l.opts.start) && l.opts.start.call (e, л), l.progress (l.opts.progress) .done (l.opts.done, l.opts.complete) .fail (l.opts.fail) .always (l.opts.always), w.fx .timer (w.extend (и, {элем: е, Anim: л, очереди: l.opts.queue})), л} w.Animation = w.extend (Pt, {tweeners: { "*": [ функция (e, t) {var n = this.createTween (e,t), return ue (n.elem, e, ie.exec (t), n), n}]}, tweener: function (e, t) {g (e)? (t = e, e = [" * "]): e = e.match (M), для (var n, r = 0, i = e.length, r <i; r ++) n = e [r], pt.tweeners [n] = pt .tweeners [п] || [], pt.tweeners [п] .unshift (т)}, Префильтры: [CT], предварительная очистка: функция (е, т) {т pt.prefilters.unshift (е): пт .prefilters.push (e)}}), w.speed = function (e, t, n) {var r = e && "object" == typeof e? w.extend ({}, e): {complete: n ||! n && t || g (e) && e, duration: e, easing: n && t || t &&! g (t) && t}; return w.fx.off?r.duration=0:"number"!=typeof r .duration && (r.duration в w.fx.speeds? r.duration = w.fx.speeds [r.duration]: r.duration = w.fx.speeds._default), null! = r.queue &&! 0! == r.queue || (r.queue = "FX"), r.old = r.complete, r.complete = функция () {г (r.old) && r.old.call (это), т. очереди && w.dequeue (это, r.queue)}, R}, w.fn.extend ({fadeTo: function (e, t, n, r) {return this.filter (ae) .css ("opacity", 0) .show (). end (). animate ({opacity: t}, e , n, r)}, aimate: function (e, t, n, r) {var i = w.isEmptyObject (e), o = w.speed (t, n, r), a = function () {var t = pt (это, w.extend ({}, e), o); (i || J.get (this, «finish»)) && t.stop (! 0)}; return a.finish = a, i ||! 1 === o.queue? this.each (a): this.queue (o.queue, a)}, stop: function (e, t, n) {var r = function (e) { var t = e.stop; delete e.stop, t (n)}; return "string"! = typeof e && (n = t, t = e, e = void 0), t &&! 1! == e && this.queue (e || "fx", []), this.each (function () {var t =! 0, i = null! = e && e + "queueHooks", o = w.timers, a = J.get (this) , if (i) a [i] && a [i] .stop && r (a [i]); else для (i в a) a [i] && a [i] .stop && ot.test (i) && r (a [i] ), для (я = o.length; я -;) о [я] .elem == это || нуль = е && о [я] .queue == е || (о [я]!!.! Anim.stop (п), т = 1, o.splice (я, 1)) ;! т && п || w.dequeue (это, е)})}, отделка: функция (е) {вернуться 1 =! = e && (e = e || "fx"), this.each (function () {var t, n = J.get (this), r = n [e + "queue"], i = n [e + "queueHooks «], о = w.timers, а = г r.length:! 0, ибо (n.finish = 0, w.queue (это, е, []), я && && i.stop i.stop.call (это, ! 0), т = o.length; т -;) о [т] .elem === это && о [т] .queue === е && (о [т] .anim.stop (0), о!. slice (t, 1)), для (t = 0; t <a; t ++) r [t] && r [t] .finish && r [t] .finish.call (this); delete n.finish})}}) , w.each (["toggle", "show", "hide"], function (e, t) {var n = w.fn [t]; w.fn [t] = function (e, r, i ) {return null == e || "boolean" == typeof e? n.apply (this, arguments): this.animate (ut (t,! 0), e, r, i)}}), w. каждый ({slideDown: ет ( "шоу"), slideUp: ет ( "скрыть"), slideToggle: ет ( "переключение"),FadeIn: {непрозрачности: "показать"}, FadeOut: {непрозрачности: "скрыть"}, fadeToggle: {непрозрачности: "переключение"}}, функция (е, т) {w.fn [е] = функция (е, п , r) {return this.animate (t, e, n, r)}}), w.timers = [], w.fx.tick = function () {var e, t = 0, n = w.timers ибо (нт = Date.now (); т <n.length; т ++)! (е = п [т]) () || п [т] == е || n.splice (т - 1 ); n.length || w.fx.stop (), nt = void 0}, w.fx.timer = function (e) {w.timers.push (e), w.fx.start ()}, w.fx.interval = 13, w.fx.start = функция () {к.т. || (ВУ =! 0, у ())}, w.fx.stop = функция () {Rt = NULL}, ш. fx.speeds = {slow: 600, fast: 200, _default: 400}, w.fn.delay = function (t, n) {return t = w.fx? w.fx.speeds [t] || t: t, n = n || "fx", this.queue (n, function (n, r) {var i = e.setTimeout (n, t); r.stop = function () {e.clearTimeout (i) }}}}, function () {var e = r.createElement ("input"), t = r.createElement ("select"). appendChild (r.createElement ("option")); e.type = "флажок», h.checkOn = ""! == e.value, h.optSelected = t.selected, (е = r.createElement ( "вход")). Значение = "т", e.type = "радио" , h.radioValue = "t" === e.value} (); var dt, ht = w.expr.attrHandle; w.fn.extend ({attr: function (e, t) {return z (this, w.attr, e, t, arguments.length> 1)}, removeAttr: function (e) {return this.each (function () {w.removeAttr (this, e)})}}), w.extend ( {attr: function (e, t, n) {var r, i, o = e.nodeType; if (3! == o && 8! == o && 2! == o) возвращает "undefined" == typeof e.getAttribute? w.prop (е, т, п) :( 1 === о && w.isXMLDoc (е) || (I = w.attrHooks [t.toLowerCase ()] || (w.expr.match.bool.test ( t)? dt: void 0)), void 0! == n? null === n? void w.removeAttr (e, t): i && "set" в i && void 0! == (r = i.set ( e, n, t))? r: (e.setAttribute (t, n + ""), n): i && "get" в i && null! == (r = i.get (e, t)) r:null == (r = w.find.attr (e, t))? void 0: r)}, attrHooks: {type: {set: function (e, t) {if (! h.radioValue && "radio" = == t && N (e, "input")) {var n = e.value; return e.setAttribute ("type", t), n && (e.value = n), t}}}}, removeAttr: function ( e, t) {var n, r = 0, i = t && t.match (M), если (i && 1 === e.nodeType) while (n = i [r ++]) e.removeAttribute (n)}}), дт = {множество: функция (е, т, п) {вернуться 1 === т w.removeAttr (е, п):!? e.setAttribute (п, п), п}}, w.each (мас. expr.match.bool.source.match (/ \ w + / g), функция (e, t) {var n = ht [t] || w.find.attr; ht [t] = функция (e, t, r) {var i, o, a = t.toLowerCase (); return r || (o = ht [a], ht [a] = i, i = null! = n (e, t, r)? a : null, ht [a] = o), i}}); var gt = / ^ (?: input | select | textarea | button) $ / i, yt = / ^ (?: a | area) $ / i ; w.fn.extend ({prop: function (e, t) {return z (this, w.prop, e, t, arguments.length> 1)}, removeProp: function (e) {return this.each ( function () {удалить это [w.propFix [e] || e]})}}), w.extend ({prop: function (e, t, n) {var r, i, o = e.nodeType, если (3! == o && 8! = = o && 2! == o) return 1 === o && w.isXMLDoc (e) || (t = w.propFix [t] || t, i = w.propHooks [t]), void 0! == n? i && "set" в i && void 0! == (r = i.set (e, n, t))? r: e [t] = n: i && "get" в i && null! == (r = i.get ( e, t))? r: e [t]}, propHooks: {tabIndex: {get: function (e) {var t = w.find.attr (e, "tabindex"); return t? parseInt (t, 10): gt.test (e.nodeName) || yt.test (e.nodeName) && e.href 0: -1}}}, propFix: { "за": "htmlFor", "класс": "имя класса "}}), h.optSelected || (w.propHooks.selected = {get: function (e) {var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null}, set: function (e) {var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)}}),w.each ([ "TabIndex", "доступен только для чтения", "MaxLength", "CELLSPACING", "CELLPADDING", "RowSpan", "COLSPAN", "useMap", "frameBorder", "contentEditable"], функция () { w.propFix [this.toLowerCase ()] = this}); функция vt (e) {return (e.match (M) || []). join ("")} функция mt (e) {return e. getAttribute && e.getAttribute ("class") || ""} function xt (e) {return Array.isArray (e)? e: "string" == typeof e? e.match (M) || []: [] } w.fn.extend ({addClass: function (e) {var t, n, r, i, o, a, s, u = 0, если (g (e)) возвращает this.each (function (t) {ш (это) .addClass (e.call (это, т, т (это)))});., если ((т = х (е)) длины), а (п = это [и ++]), если (я = mt (n), r = 1 === n.nodeType && "" + vt (i) + "") {a = 0, тогда как (o = t [a ++]) r.indexOf ("" + o + "" ) <0 && (r + = o + ""); i! == (s = vt (r)) && n.setAttribute ("class", s)} return this}, removeClass: function (e) {var t, n, r, i, o, a, s , u = 0, если (g (e)) возвращает this.each (function (t) {w (this) .removeClass (e.call (this, t, mt (this)))}), если (! arguments .length) return this.attr ("class", ""), если ((t = xt (e)). length) while (n = this [u ++]), если (i = mt (n), r = 1 === n.nodeType && "" + vt (i) + "") {a = 0; while (o = t [a ++]) while (r.indexOf ("" + o + "")> - 1) r = r.replace ("" + o + "", ""); i! == (s = vt (r)) && n.setAttribute ("class", s)} return this}, toggleClass: function (e, t) {var n = typeof e, r = "string" === n || Array.isArray (e); return "boolean" == typeof t && r? t? this.addClass (e): this.removeClass (e): г (е) this.each (функция (п) {ш (этот) .toggleClass (e.call (это, п, т (это), т), т)}):? this.each (функция () { var t,я, о, а, если (г) {= 0, а = ш (это), а = х (е), в то время (т = а [I ++]) o.hasClass (т) o.removeClass (т? ): o.addClass (t)} else void 0! == e && "boolean"! == n || ((t = mt (this)) && J.set (this, "__ className __", t), this.setAttribute && this .setAttribute ("class", t ||! 1 === e? "": J.get (this, "__ className __") || ""))})}, hasClass: function (e) {var t, n, r = 0, t = "" + e + "", тогда как (n = this [r ++]), если (1 === n.nodeType && ("" + vt (mt (n)) + "") .indexOf (t)> - 1) return! 0; return! 1}}); var bt = / \ r / g; w.fn.extend ({val: function (e) {var t, n, r, i = this [0]; {if (arguments.length) return r = g (e), this.each (function (n) {var i; 1 === this.nodeType && (null == (i = r? e. call (this, n, w (this) .val ()): e)? i = "": "number" == typeof i? i + = "": Array.isArray (i) && (i = w.map (я,function (e) {return null == e? "": e + ""})), (t = w.valHooks [this.type] || w.valHooks [this.nodeName.toLowerCase ()]) && "set "в t && void 0! == t.set (this, i," value ") || (this.value = i))}), если (i) return (t = w.valHooks [i.type] || w.valHooks [i.nodeName.toLowerCase ()]) && "get" в t && void 0! == (n = t.get (i, "value"))? n: "string" == typeof (n = i .value)? n.replace (bt, ""): null == n? "": n}}}), w.extend ({valHooks: {option: {get: function (e) {var t = w .find.attr (e, "value"); return null! = t? t: vt (w.text (e))}}, выберите: {get: function (e) {var t, n, r, i = e.options, о = e.selectedIndex, а = "выбрать-один" === e.type, s = нуль: [], и = а O + 1:? i.length, ибо (г = о <0 и: А о:?! 0; г <и; г ++), если (. ((п = я [г]) выбран || г === о) && n.disabled && (n.parentNode. инвалидов ||! N (n.parentNode»optgroup "))) {if (t = w (n) .val (), a) возвращает t; s.push (t)} return s}, set: function (e, t) {var n, r, i = e.options, о = w.makeArray (т), а = i.length;., а (а -) ((г = я [а]) = выбран w.inArray (w.valHooks.option.get ( r), o)> - 1) && (n =! 0); return n || (e.selectedIndex = -1), o}}}}), w.each (["radio", "checkbox"] , function () {w.valHooks [this] = {set: function (e, t) {if (Array.isArray (t)) return e.checked = w.inArray (w (e) .val (), t )> - 1}}, h.checkOn || (w.valHooks [this] .get = function (e) {return null === e.getAttribute ("value")? "On": e.value}) }), h.focusin = "onfocusin" в e; var wt = / ^ (?: focusinfocus | focusoutblur) $ /, Tt = function (e) {e.stopPropagation ()}, w.extend (w.event, {trigger: function (t, n, i, o) {var a, s, u, l, c, p, d, h, v = [i || r], m = f.call (t, "type ") t.type: T, X = f.call (т,?" пространства имен ") t.namespace.split (?" "):. []; если (с = ч = и = I = I || г , 3! == я.NODETYPE && 8 == i.nodeType && wt.test (т + w.event.triggered) && (m.indexOf ()>! " "-".". 1 && (т = (х = m.split ()) сдвига (), x.sort ()), c = m.indexOf (":") <0 && "on" + m, t = t [w.expando]? t: new w.Event (m, "object" = = typeof t && t), t.isTrigger = o? 2: 3, t.namespace = x.join ("."), t.rnamespace = t.namespace? new RegExp ("(^ | \\.)" + x .join ("\\. (?:. * \\. |)") + "(\\. | $)"): null, t.result = void 0, t.target || (t.target = я), п = NULL == п [т]: w.makeArray (п, [т]), г = w.event.special [м] || {}, о || d.trigger ||! 1! == d.trigger.apply (я, п))) {если (! о &&! d.noBubble &&! у (я)) {для (л = d.delegateType || м, wt.test (L + M ) || (с = s.parentNode); s; s = s.parentNode) v.push (ы), U = s; U === (i.ownerDocument || г) && v.push (u.defaultView | | u.parentWindow || е)} а = 0;!, а ((s = v [A ++]) && т.isPropagationStopped ()) ч = с, t.type = а> 1 л: d.bindType || м, (р = (J.get (с, "события") || {}) [t.type] && J .get (с, "ручка")) && p.apply (с, п), (р = с && s [с]) && p.apply && Y (ы) && (t.result = p.apply (с, п) ,! 1 === t.result && t.preventDefault ()); return t.type = m, o || t.isDefaultPrevented () || d._default &&! 1! == d._default.apply (v.pop (), n ) ||! у (я) || с && г (я [м]) &&! у (я) && ((и = я [с]) && (я [с] = нуль), w.event.triggered = т , t.isPropagationStopped () && h.addEventListener (m, Tt), i [m] (), t.isPropagationStopped () && h.removeEventListener (m, Tt), w.event.triggered = void 0, u && (i [c ] = u)), t.result}}, имитировать: function (e, t, n) {var r = w.extend (новый w.Event, n, {type: e, isimulated:! 0}); w .event.trigger (r, null, t)}}), w.fn.extend ({trigger: function (e, t) {return this.each (function () {w.event.trigger (e,t, this)})}, triggerHandler: function (e, t) {var n = this [0]; if (n) return w.event.trigger (e, t, n,! 0)}}), h .focusin || w.each ({focus: "focusin", blur: "focusout"}, function (e, t) {var n = function (e) {w.event.simulate (t, e.target, w .event.fix (e))}; w.event.special [t] = {setup: function () {var r = this.ownerDocument || this, i = J.access (r, t); i || r.addEventListener (e, n,! 0), J.access (r, t, (i || 0) +1)}, teardown: function () {var r = this.ownerDocument || this, i = J .access (г, т) -1;? я J.access (г, т, I) :( r.removeEventListener (е, п, 0!), J.remove (г, т))}}}); var Ct = e.location, Et = Date.now (), kt = / \? /; w.parseXML = function (t) {var n; if (! t || "string"! = typeof t) return null , try {n = (новый e.DOMParser) .parseFromString (t, "text / xml")} catch (e) {n = void 0} return n &&! n.getElementsByTagName ("parsererror"). length || w. error ("Invalid XML:" + t), n}; var St = / \ [\] $ /, Dt = / \ r? \ n / g,Nt = / ^ (: submit | button | image | reset | file) $ / i, At = / ^ (?: input | select | textarea | keygen) / i; функция jt (e, t, n, r) {var i; if (Array.isArray (t)) w.each (t, function (t, i) {n || Sttest (e)? r (e, i): jt (e + "[" + («object» == typeof i && null! = i? t: "") + "]", i, n, r)}), else if (n || "object"! == x (t)) r ( e, t), else для (i в t) jt (e + "[" + i + "]", t [i], n, r)} w.param = function (e, t) {var n, r = [], i = function (e, t) {var n = g (t)? t (): t; r [r.length] = encodeURIComponent (e) + "=" + encodeURIComponent (null == n? " «:! п)}, если (Array.isArray (е) || e.jquery && w.isPlainObject (е)) w.each (е, функция () {я (this.name, this.value)}); else для (n в e) jt (n, e [n], t, i); return r.join ("&")}, w.fn.extend ({serialize: function () {return w.param ( this.serializeArray ())}, serializeArray: function () {return this.map (function () {var e = w.prop (this,«элементы»); return e? w.makeArray (e): this}). filter (function () {var e = this.type; return this.name &&! w (this) .is (": disabled") && At .test (this.nodeName) &&! Nt.test (e) && (this.checked ||! pe.test (e))}). map (function (e, t) {var n = w (this). val (); return null == n? null: Array.isArray (n)? w.map (n, function (e) {return {name: t.name, value: e.replace (Dt, "\ r \ n ")}}): {name: t.name, value: n.replace (Dt," \ r \ n ")}}). get ()}}); var qt = /% 20 / g, Lt = / #. * $ /, Ht = / ([? &]) _ = [^ &] * /, Ot = / ^ (. *?): [\ T] * ([^ \ r \ n] * ) $ / г, Pt = / ^ (?: о | приложение | приложение-хранения | + - расширение | файл | Рез | виджет). $ /, Mt = / ^ (?: GET | ГОЛОВА) $ /, Rt = / ^ \ / \ //, It = {}, Wt = {}, $ т = "* /" CONCAT ( "*"), Bt = r.createElement ( "а");. Bt.href = Ct .href; функция Ft (e) {return function (t, n) {"string"! = typeof t && (n = t, t = "*"); var r, i = 0, o = t.toLowerCase () ,матч (М) || [];? если (г (п)), а (г = о [я ++]) "+" === г [0] (г = r.slice (1) || "*" , (e [r] = e [r] || []). unshift (n)): (e [r] = e [r] || []). push (n)}} функция _t (e, t, n, r) {var i = {}, o = e === Wt; функция a (s) {var u; return i [s] =! 0, w.each (e [s] || [ ], функция (e, s) {var l = s (t, n, r); return "string"! = typeof l || o || i [l]? o?! (u = l): void 0 : (t.dataTypes.unshift (l), a (l) ,! 1)}), u} return a (t.dataTypes [0]) ||! i ["*"] && a ("*")} функция zt (e, t) {var n, r, i = w.ajaxSettings.flatOptions || {}; для (n in t) void 0! == t [n] && ((i [n]? e: r || (r = {})) [n] = t [n]); return r && w.extend (! 0, e, r), e} функция Xt (e, t, n) {var r, i, o, a, s = e.contents, u = e.dataTypes; while ("*" === u [0]) u.shift (), void 0 === r && (r = e.mimeType || t .getResponseHeader («Content-Type»)); if (r) для (i в s), если (s [i] && s [i] .test (r)) {u.unshift (i); break}, если (u [0] в n) o = u [0];else {для (i в n) {if (! u [0] || e.converters [i + "" + u [0]]) {o = i; break} a || (a = i)} o = o || a} if (o) return o! == u [0] && u.unshift (o), n [o]} функция Ut (e, t, n, r) {var i, o, a, s , u, l = {}, c = e.dataTypes.slice (), если (c [1]) для (a в e.converters) l [a.toLowerCase ()] = e.converters [a]; o = c.shift (), в то время (о), если (e.responseFields [O] && (п [e.responseFields [O]] = т) ,! ?u && г && && e.dataFilter (т = e.dataFilter (т, e.dataType )), u = o, o = c.shift ()), если ("*" === o) o = u; else if ("*"! == u && u! == o) {если (! (a = l [u + "" + o] || l ["*" + o])) для (i в l), если ((s = i.split ("")) [1] === o && (a = l [u + "" + s [0]] || l ["*" + s [0]])) {! 0 === a? a = l [i] :! 0! == l [i] && (o = s [0], c.unshift (s [1])); break} if (! 0! == a), если (a && e ["throws"]) t = a (t); else try { т = а (т)} поймать (е) {возвращение {состояния: "parsererror", ошибка:? а е:»Нет преобразования из «+ u +» в «+ o}}} return {state:« success », data: t}} w.extend ({active: 0, lastModified: {}, etag: {}, ajaxSettings: {url : Ct.href, типа: "GET", isLocal: Pt.test (Ct.protocol), глобальный: 0, ProcessData: 0, асинхронная: 0, CONTENTTYPE:! "применение / х-WWW-форм-urlencoded; charset = UTF-8 ", принимает: {" * ": $ t, текст:" text / plain ", html:" text / html ", xml:" application / xml, text / xml ", json:" application / json, text / javascript "}, содержимое: {xml: / \ bxml \ b /, html: / \ bhtml /, json: / \ bjson \ b /}, responseFields: {xml:" responseXML ", текст:" responseText ", json:" responseJSON "}, преобразователи: {" * text ": String," text html ":! 0," text json ": JSON.parse," text xml ": w.parseXML}, flatOptions: {url :! 0, context:! 0}}, ajaxSetup: function (e, t) {return t? Zt (zt (e, w.ajaxSettings), t): zt (w.ajaxSettings, e)}, ajaxPrefilter: Ft (It), ajaxTransport: Ft (Wt), ajax: function (t, n) {"object" == typeof t && (n = t , t = void 0), n = n || {}; var i, o, a, s, u, l, c, f, p, d, h = w.ajaxSetup ({}, n), g = h.context || h, y = h.context && (g.nodeType || g.jquery)? w (g): w.event, v = w.Deferred (), m = w.Callbacks ("once memory" ), x = h.statusCode || {}, b = {}, T = {}, C = "отменено", E = {readyState: 0, getResponseHeader: function (e) {var t; if (c) { если (ы) {s = {}, тогда (т = Ot.exec (а)) с [т [1] .toLowerCase ()] = т [2]} T = s [e.toLowerCase ()]} return null == t? null: t}, getAllResponseHeaders: function () {return c? a: null}, setRequestHeader: function (e, t) {return null == c && (e = T [e.toLowerCase ()] = T [e.toLowerCase ()] || e, b [e] = t), this}, overrideMimeType: function (e) {return null == c && (h.mimeType = e), this}, statusCode: function (e) {var t; если (e) если (c) E. always (e [E.status]);else for (t in e) x [t] = [x [t], e [t]]; return this}, abort: function (e) {var t = e || C; return i && i.abort (t) , к (0, т), это}}; если (v.promise (Е), h.url = ((т || h.url || Ct.href) + "") заменить (Rt, Ct.. протокол + "//"), h.type = n.method || n.type || h.method || h.type, h.dataTypes = (h.dataType || "*"). toLowerCase (). матч (М) || [ ""], нуль == h.crossDomain) {л = r.createElement ( "а"); попробовать {l.href = h.url, l.href = l.href, h.crossDomain = Bt.protocol + "//" + Bt.host! = l.protocol + "//" + l.host} поймать (е) {h.crossDomain! = 0}} если (h.data && && h.processData "строка"! = typeof h.data && (h.data = w.param (h.data, h.traditional)), _ t (It, h, n, E), c) return E; (f = w.event && h.global) && 0 == w.active ++ && w.event.trigger ( "ajaxStart"), h.type = h.type.toUpperCase (), h.hasContent =! Mt.test (h.type), о = h.url. заменить (Lt,""), H.hasContent? H.data && && h.processData 0 === (h.contentType || ""). IndexOf ( "применение / х-WWW-форм-urlencoded") && (h.data = h.data. replace (qt, "+")): (d = h.url.slice (o.length), h.data && (h.processData || "string" == typeof h.data) && (o + = (kt. test (o)? "&": "?") + h.data, delete h.data), 1 === h.cache && (o = o.replace (Ht, "$ 1"), d = (kt .test (о) "и": "?") + "_ =" + Et +++ г), h.url = а + г), h.ifModified && (w.lastModified [о] && E.setRequestHeader ( "If-Modified-Since", w.lastModified [о]), w.etag [о] && E.setRequestHeader ( "If-None-Match", w.etag [о])), (h.data && h.hasContent &&! 1! == h.contentType || n.contentType) && E.setRequestHeader ( "Content-Type", h.contentType), E.setRequestHeader ( "Accept", h.dataTypes [0] && h.accepts [h.dataTypes [0]]? h.accepts [h.dataTypes [0]] + ( "*"! == h.dataTypes [0]? "," + $ t + "; q = 0.01": ""): h.accepts ["*"]), для (p в h.headers) E.setRequestHeader (p, h.headers [p]); (h.beforeSend && (! 1 === h.beforeSend.call (g, E, h) || c)) return E.abort (), если (C = "abort", m.add (h.complete) , E.done (h.success), E.fail (h.error), г = _t (Вт, Н, N, Е)) {если (E.readyState = 1, F && y.trigger ( "ajaxSend", [ E, h]), c) return E; h.async && h.timeout> 0 && (u = e.setTimeout (function () {E.bort ("timeout")}, h.timeout)); try {c =! 1, i.send (b, k)} catch (e) {if (c) throw e; k (-1, e)}} else k (-1, «No Transport»); функция k (t, n , r, s) {var l, p, d, b, T, C = n; c || (c =! 0, u && e.clearTimeout (u), i = void 0, a = s || "", E.readyState = т> 0 4: 0, л = т>= 200 && т <300 || 304 === т, г && (Ь = Х (А, Е, т)), б = Ut (Л, В, Е, л), л? (H.ifModified && ((Т = Е .getResponseHeader ( "Last-Modified")) && (w.lastModified [O] = Т), (Т = E.getResponseHeader ( "ETag")) && (w.etag [O] = T)), 204 == = т || "голова" === h.type С = "nocontent":?! 304 === т С = "notmodified" :( С = b.state, р = b.data, л = (г = b.error))) :( d = C, T! && С || (С = "ошибка", т <0 && (т = 0))), E.status = т, E.statusText = (п || С ) + "", l? v.resolveWith (g, [p, C, E]): v.rejectWith (g, [E, C, d]), E.statusCode (x), x = void 0, f && y .trigger (л "ajaxSuccess": "ajaxError", [E, H, L P: d]), m.fireWith (г, [Е, С]), F && (y.trigger ( "ajaxComplete", [ E, h]), - w.active || w.event.trigger ("ajaxStop")))} return E}, getJSON: function (e, t, n) {return w.get (e, t, п, "JSON")}, getScript:функция (e, t) {return w.get (e, void 0, t, "script")}}), w.each (["get", "post"], function (e, t) {w [ t] = функция (e, n, r, i) {return g (n) && (i = i || r, r = n, n = void 0), w.ajax (w.extend ({url: e , type: t, dataType: i, data: n, success: r}, w.isPlainObject (e) && e))}}), w._evalUrl = function (e) {return w.ajax ({url: e, Тип: "GET", DATATYPE: "сценарий", кэш: 0, асинхронная: 1, глобальный: 1, "бросает": 0})}, w.fn.extend ({wrapAll: функция (е) {var t; return this [0] && (g (e) && (e = e.call (это [0])), t = w (e, это [0] .ownerDocument) .eq (0) .clone (! 0), это [0] .parentNode && t.insertBefore (это [0]), t.map (function () {var e = this; while (e.firstElementChild) e = e.firstElementChild; return e}). append (this)), this}, wrapInner: function (e) {return g (e)? this.each (function (t) {w (this) .wrapInner (e.call (this, t))}): this.each (function () {var t = w (this), n = t.content (); n.length? n.wrapAll (e): t.append (e)})}, wrap: function (e) {var t = g (e); return this.each (function (n) { w (this) .wrapAll (t? e.call (this, n): e)})}, разворот: function (e) {return this.parent (e) .not ("body"). each (function ( ) {ш (это) .replaceWith (this.childNodes)}), это}}), w.expr.pseudos.hidden = функция (е) {вернуться! w.expr.pseudos.visible (е)}, ш. expr.pseudos.visible = function (e) {return !! (e.offsetWidth || e.offsetHeight || e.getClientRects (). length)}, w.ajaxSettings.xhr = function () {try {return new e .XMLHttpRequest} catch (e) {}}; var Vt = {0: 200,1223: 204}, Gt = w.ajaxSettings.xhr (); h.cors = !! Gt && "withCredentials" в Gt, h.ajax = Gt = !! Gt, w.ajaxTransport (function (t) {var n, r; if (h.cors || Gt &&! T.crossDomain) return {send: function (i, o) {var a, s = t.xhr (), если (s.open (t.type, t.url, t.async, t.username, t.password), t.xhrFields) для (a в t.xhrFields) s [a] = t.xhrFields [а]; т.mimeType && s.overrideMimeType && s.overrideMimeType (t.mimeType), t.crossDomain || i ["X-Requested-With"] || (i ["X-Requested-With"] = "XMLHttpRequest"); для (a in i ) s.setRequestHeader (a, i [a]); n = function (e) {return function () {n && (n = r = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "abort" === e? s.abort (): "error" === e? "number"! = typeof s.status? o (0, "error"): o (s.status, s.statusText): o (Vt [s.status] || s.status, s.statusText, "text"! == (s.responseType || "text") || "string"! = typeof s.responseText ? {двоичным: s.response}: {текст: s.responseText}, s.getAllResponseHeaders ()))}}, s.onload = п (), г = s.onerror = s.ontimeout = п ( "ошибка" ), void 0! == s.onabort? s.onabort = r: s.onreadystatechange = function () {4 === s.readyState && e.setTimeout (function () {n && r ()})}, n = n ("abort"); try {s.send (t.hasContent && t.data || null)} catch (e) {if (n) throw e} }, прервать: функция () {п && п ()}}}), w.ajaxPrefilter (функция (е) {e.crossDomain && (e.contents.script = 1!)}), w.ajaxSetup ({принимает: {сценарий : "text / javascript, application / javascript, application / ecmascript, application / x-ecmascript"}, содержимое: {script: / \ b (?: java | ecma) script \ b /}, преобразователи: {"text script" : function (e) {return w.globalEval (e), e}}}), w.ajaxPrefilter ("script", function (e) {void 0 === e.cache && (e.cache =! 1), e.crossDomain && (e.type = "GET")}), w.ajaxTransport ("script", function (e) {if (e.crossDomain) {var t, n; return {send: function (i, o) {t = w ("<script>"). prop ({charset: e.scriptCharset, src: e.url}). on ("ошибка загрузки", n = функция (e) {t.remove (),п = нуль, е && о ( "ошибка" === e.type 404: 200, e.type)}), r.head.appendChild (т [0])}, прервать: функцию () {п && п ()} }}}); var Yt = [], Qt = / (=) \? (? = & | $) | \? \? /; w.ajaxSetup ({jsonp: "callback", jsonpCallback: function () { var e = Yt.pop () || w.expando + "_" + Et ++; вернуть это [e] =! 0, e}}), w.ajaxPrefilter ("json jsonp", function (t, n, r) {var i, o, a, s =! 1! == t.jsonp && (Qt.test (t.url)? "url": "string" == typeof t.data && 0 === (t.contentType || "") .indexOf ( "применение / х-WWW-форм-urlencoded") && Qt.test (t.data) && "данные"); если (ы || "JSONP" === t.dataTypes [0]) return i = t.jsonpCallback = g (t.jsonpCallback)? t.jsonpCallback (): t.jsonpCallback, s? t [s] = t [s] .replace (Qt, "$ 1" + i) :! 1! == t.jsonp && (t.url + = (kt.test (t.url) "&": "?") + t.jsonp +»= "+ i), t.converters [" script json "] = function () {return a || w.error (i +" не был вызван "), a [0]}, t.dataTypes [0] =" json ", o = e [i], e [i] = function () {a = arguments}, r.always (function () {void 0 === o? w (e) .removeProp (i): e [i] = o, t [i] && (t.jsonpCallback = n.jsonpCallback, Yt.push (i)), a && g (o) && o (a [0]), a = o = void 0}), script "}), h.createHTMLDocument = function () {var e = r.implementation.createHTMLDocument (" "). body; return e.innerHTML =" <form> </ form> <form> </ form> ", 2 === e.childNodes.length} (), w.parseHTML = function (e, t, n) {if ("string"! = Typeof e) return []; "boolean" == typeof t && (n = t, t =! 1); var i, o, a; return t || (h.createHTMLDocument? ((i = (t = r.implementation.createHTMLDocument ("")). createElement ("base")). HREF = r.location.href, t.head.AppendChild (я)):? Т = г), о = A.exec (е), а = п && [], о [t.createElement (о [1])] :( O = х ([е], t, a), a && a.length && w (a) .remove (), w.merge ([], o.childNodes))}, w.fn.load = function (e, t, n) {var r, i, o, a = this, s = e.indexOf (""); return s> -1 && (r = vt (e.slice (s)), e = e.slice (0, s)), g (t) ? (n = t, t = void 0): t && "object" == typeof t && (i = "POST"), a.length> 0 && w.ajax ({url: e, type: i || "GET", DATATYPE: "HTML", данные:. т}) сделано (функция (е) {о = аргументы, a.html (г ш ( "<DIV>") добавить (w.parseHTML (е)) найти (?.. г): д.)}) всегда (п && функция (е, т) {a.each (функция () {n.apply (это, о || [e.responseText, т, е])})}), этот }, w.each ([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], функция (е, т) {ш.fn [t] = function (e) {return this.on (t, e)}}), w.expr.pseudos.animated = function (e) {return w.grep (w.timers, function (t) { return e === t.elem}). length}, w.offset = {setOffset: function (e, t, n) {var r, i, o, a, s, u, l, c = w.css (е, "положение"), е = ш (е), р = {}; "статические" === C && (e.style.position = "относительно"), с = f.offset (), о = ш .css (е, "верхний"), и = w.css (е, "влево"), (л = ( "абсолютный" === с || "фиксированный" === с) && (о + и) .indexOf ( "авто")> -. 1) (а = (г = f.position ()) сверху, я = r.left) :( а = parseFloat (о) || 0, г = parseFloat (U ) || 0), г (т) && (т = t.call (е, п, w.extend ({}, с))), нулевая! = t.top && (p.top = t.top-ы .top + a), null! = t.left && (p.left = t.left-s.left + i), «используя» в t? t.using.call (e, p): f.css (p )}}, w.fn.extend ({offset: function (e) {if (arguments.length) return void 0 === e? this: this.each (function (t) {w.offset.setOffset (this ,e, t)}); var t, n, r = this [0]; if (r) return r.getClientRects (). length? (t = r.getBoundingClientRect (), n = r.ownerDocument.defaultView, { top: t.top + n.pageYOffset, left: t.left + n.pageXOffset}): {top: 0, left: 0}}, position: function () {if (this [0]) {var e, т, п, г = это [0], I = {верх: 0, слева: 0}, если ( "фиксированные" === w.css (г, "позиция")) т = r.getBoundingClientRect (); еще {т = this.offset (), п = r.ownerDocument, е = r.offsetParent || n.documentElement, в то время (е && (е === n.body || е === n.documentElement) &&» статический "=== w.css (е," позиция ")) е = e.parentNode; е && е == г && 1 === e.nodeType && ((я = ш (е) .offset ()) сверху + = ш!. .css (е, "borderTopWidth", 0!), i.left + = w.css (е, "borderLeftWidth", 0!))} {возвращение верхней части: t.top-i.top-w.css (г, "marginTop",! 0), left: t.left-i.left-w.css (r, "marginLeft",! 0)}}}, offsetParent: function () {вернуть это.map (function () {var e = this.offsetParent; while (e && "static" === w.css (e, "position")) e = e.offsetParent, return e || be})}}), w.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (e, t) {var n = "pageYOffset" === t; w.fn [e] = function (r) {return z (это функция (e, r, i) {var o; if (y (e)? o = e: 9 === e.nodeType && (o = e.defaultView), void 0 === i) return o ? о [т]: е [г]; о o.scrollTo (п o.pageXOffset:? я, н я: o.pageYOffset): е [г] = г}, е, г, arguments.length) }}), w.each ([ "верх", "влево"], функция (е, Т) {w.cssHooks [т] = _ е (h.pixelPosition, функция (е, п) {если (п) возврата п = Ре (е, т), We.test (п) ш (е) .position () [т] + "ПВ": п})}), w.each ({высота: "высота", ширина : "ширина"}, функция (е, т) {w.each ({обивка: "внутренний" + е, содержание: т "": "внешний" + е}, функция (п, г) {w.fn [г] = функция (я,o) {var a = arguments.length && (n || "boolean"! = typeof i), s = n || (! 0 === i ||! 0 === o? "margin": "border" ); return z (this, function (t, n, i) {var o; return y (t)? 0 === r.indexOf ("external")? t ["inner" + e]: t.document .documentElement [ "клиент" + е]: 9 === t.nodeType (о = t.documentElement, Math.max (t.body [ "прокрутки" + е], о [ "прокрутки" + е], т .body ["offset" + e], o ["offset" + e], o ["client" + e])): void 0 === i? w.css (t, n, s): w. style (t, n, i, s)}, t, a? i: void 0, a)}})}, w.each ("размытие фокуса фокуса фокуса изменения размера прокрутка клика мыши dblclick mousedown mouseup mousemove mouseover mouseout mouseenter изменение мыши выберите «отправить» keydown keydown keymenus «.split (« »), function (e, t) {w.fn [t] = function (e, n) {return arguments.length> 0? this.on (t, null, е, п): this.trigger (т)}}), w.fn.extend ({hover: function (e, t) {return this.mouseenter (e) .mouseleave (t || e)}}), w.fn.extend ({bind: function (e, t, n) {return this.on (e, null, t, n)}, unbind: functio